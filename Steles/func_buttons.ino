
// Parse a slice-keypress that was generated while in SLICE or OVERRVIEW mode
void slicePress(byte col, byte row) {

    byte seq = 0; // Will hold the seq-index of whatever seq is being modified by the given command
    byte slice = 0; // Will hold the position of the slice that corresponds to the button that's been pressed
    if (BOTCTRL & B00000001) { // If the OVERVIEW-button is being held...
        seq = col + (4 * row); // Get the seq-index of the button's corresponding OVERVIEW-seq
        seq += 16 * (LEFTCTRL & B00000001); // If the RIGHT-SIDE key is held, add 16 to the seq value
    } else { // Else, if OVERVIEW isn't being held...
        slice = col + (4 * (LEFTCTRL & B00000001)); // Get the slice that corresponds to this column, plus 4 if RIGHT-SIDE is held
        seq = SLICE_ROW[row]; // Get the index of the seq in the given slice-row
    }

    if ((!BOTCTRL) && !(LEFTCTRL & B00011110)) { // If no control-buttons are being held (aside from, optionally, the RIGHT-SIDE button)...
        byte size = SEQ_SIZE[seq >> 1] >> (4 * (seq & 1)); // Get the size-value of the sequence
        size = size ? size : 16; // If the sequence's stored size-value is 0, treat it as 16
        SEQ_POS[seq] = 24 * size * slice; // Set the seq's position to correspond with the given slice-point
        SEQ_PLAYING[seq >> 3] |= 1 << (seq & 7); // Set the seq's PLAYING-bit to 1
    } else if (LEFTCTRL == B00000001) { // If the FLING button is held...
        if (FLINGSEQ == 255) { // If the FLINGSEQ slot hasn't been filled by a FLING keypress yet...
            FLINGSEQ = seq; // Put the given sequence into the FLINGSEQ slot
        } else { // Else, if the FLINGSEQ slot is filled...
            SLICE_SLOT[col] = FLINGSEQ; // Fill the SLICE_SLOT corresponding to the key's column with the seq in the FLINGSEQ slot
            FLINGSEQ = 255; // Set the FLINGSEQ slot to an empty dummy-value
        }
    } else if (BOTCTRL == B00000001) { // If only the OVERVIEW button is held...
        SEQ_CMD[seq] = 0; // Empty out whatever cued commands the sequence might have
        SEQ_POS[seq] = 0; // Set the seq's tick-position to correspond with the first slice-point, which is 0
        SEQ_PLAYING[seq >> 3] |= 1 << (seq & 7); // Set the seq's PLAYING-bit to 1
    } else if (BOTCTRL == B00000011) { // If the OVERVIEW-OFF chord is held...
        SEQ_CMD[seq] = 0; // Empty out whatever cued commands the sequence might have
        SEQ_POS[seq] = 0; // Reset the seq's tick-position
        SEQ_PLAYING[seq >> 3] &= ~(1 << (seq & 7)); // Set the seq's PLAYING-bit to 0
    } else if ( // If...
        (BOTCTRL == B00001000) // The CUE-1 button is held...
        || (BOTCTRL == B00001001) // Or the OVERVIEW-CUE-1 chord is held...
    ) { // Then...
        SEQ_CMD[seq] = B10000001 | (slice << 2); // Cue an ON for this seq's given slice, on the next global 1-beat
    } else if ( // If...
        (BOTCTRL == B00010000) // The CUE-8 button is held...
        || (BOTCTRL == B00010001) // Or the OVERVIEW-CUE-8 chord is held...
    ) { // Then...
        SEQ_CMD[seq] = B10000010 | (slice << 2); // Cue an ON for this seq's given slice, on the next global 8-beat
    } else if ( // If...
        (BOTCTRL == B00000110) // The OFF-SCATTER chord is held...
        || (BOTCTRL == B00000111) // Or the OVERVIEW-OFF-SCATTER chord is held...
    ) { // Then...
        SEQ_SCATTER[seq] = 0; // Reset the seq's SCATTER-data
        SEQ_OFFSET[seq] = 0; // Reset the seq's SCATTER-controlled tick-position offset
    } else if ( // If...
        (BOTCTRL == B00001010) // The OFF-CUE-1 chord is held...
        || (BOTCTRL == B00001011) // Or the OVERVIEW-OFF-CUE-1 chord is held...
    ) { // Then...
        SEQ_CMD[seq] = B00000001; // Cue an OFF for this seq, on the next global 1-beat
    } else if ( // If...
        (BOTCTRL == B00010010) // The OFF-CUE-8 chord is held...
        || (BOTCTRL == B00010011) // Or the OVERVIEW-OFF-CUE-8 chord is held...
    ) { // Then...
        SEQ_CMD[seq] = B00000010; // Cue an OFF for this seq, on the next global 8-beat
    } else if (BOTCTRL == B00000010) { // If the OFF button is held...
        SEQ_CMD[seq] = 0; // Empty out whatever cued commands the sequence might have
        SEQ_POS[seq] = 0; // Reset the seq's tick-position
        SEQ_PLAYING[seq >> 3] &= ~(1 << (seq & 7)); // Set the seq's PLAYING-bit to 0
    } else if (BOTCTRL == B00000100) { // If the SCATTER button is held...
        SEQ_SCATTER[seq] ^= 1 << slice; // Toggle this slice-button's SCATTER-bit
    } else if (BOTCTRL == B00001100) { // If the BPM chord is held...
        BPM = max(20, BPM ^ (1 << slice)); // Set the BPM to a binary value corresponding to the keystroke, with a minimum of 20
    } else if (LEFTCTRL == B00000010) { // If the EXCLUDE button is held...
        byte sbin = 1 << slice; // Get this slice-press's binary value
        if (SEQ_EXCLUDE[seq] ^ sbin) { // If any open slices would remain after an EXCLUDE operation...
            SEQ_EXCLUDE[seq] ^= sbin; // Set the sequence's excluded slices to a binary value corresponding to the keystroke
            word slicewidth = 24 * (SEQ_SIZE[seq >> 1] >> (4 * (seq & 1))); // Get the number of ticks in a single slice within this seq
            word seqwidth = slicewidth * 8; // Get the total number of ticks within the seq
            while (true) { // Loop until reaching a break point...
                byte spos = byte(floor(SEQ_POS[seq] / (24 * SEQ_SIZE[seq]))); // Get the seq's tick-position's corresponding slice
                if (SEQ_EXCLUDE[seq] & (1 << spos)) { // If the slice holding the seq's tick-position isn't excluded...
                    break; // Break from the loop, as everything is fine
                } // Otherwise, do the following things:
                SEQ_POS[seq] = (SEQ_POS[seq] + slicewidth) % seqwidth; // Increase the tick-position by 1 slice worth of ticks, wrapped to the seq's size
            }
        }
    } else if (LEFTCTRL == B00000100) { // If the RANDOMIZE-SLICE button is held...
        SEQ_RAND[seq] = 1 << col; // Toggle this column's RANDOMIZE-SLICE bit
    } else if (LEFTCTRL == B00001000) { // If the RANDOMIZE-VELOCITY button is held...
        SEQ_RAND[seq] = 1 << (4 + col); // Toggle this column's RANDOMIZE-VELOCITY bit
    }

}

// Parse a note-keypress that was generated while in RECORDMODE mode
void recPress(byte col, byte row) {

    byte slice = col + (4 * (LEFTCTRL & B00000001)); // Get the slice that corresponds to this column, plus 4 if RIGHT-SIDE is held

    if (BOTCTRL == B00000010) { // If the CHANNEL button is held...
        CHANNEL = max(0, min(15, CHANNEL + ((col + (col >> 1)) - 2))); // Shift the CHANNEL value by -2, -1, 1, or 2, depending on keystroke's column
    } else if (BOTCTRL == B00000100) { // If the OCTAVE button is held...
        OCTAVE = max(0, min(9, OCTAVE + ((col + (col >> 1)) - 2))); // Shift the OCTAVE value by -2, -1, 1, or 2, depending on keystroke's column
    } else if (BOTCTRL == B00001000) { // If the VELOCITY button is held...
        VELOCITY = max(1, min(127, VELOCITY + pow(((col + (col >> 1)) - 2), 4))); // Shift the VELOCITY value by -16, -1, 1, or 16, depending on keystroke's column
    } else if (BOTCTRL == B00010000) { // If the HUMANIZE button is held...
        HUMANIZE ^= 1 << slice; // Toggle this slice-button's HUMANIZE-bit
    } else if (BOTCTRL == B00000011) { // If the TIME-QUANTIZE chord is held...
        QUANTIZE ^= 1 << slice; // Toggle this slice-button's QUANTIZE-bit
    } else if (BOTCTRL == B00000101) { // If the SEQ-SIZE chord is held...
        SEQ_SIZE[SLICE_SLOT[0]] ^= 1 << slice; // Toggle this slice-button's SEQ_SIZE bit, for whichever sequence is in the topmost slicing row
    } else if (BOTCTRL == B00001001) { // If the NOTE-DURATION chord is held...
        DURATION ^= 1 << slice; // Toggle this slice-button's DURATION-bit
    } else if (BOTCTRL == B00010001) { // If the CLOCK MASTER/FOLLOW chord is held...
        if (CLOCKMASTER && PLAYING) { // If this was previously in MASTER mode, and currently PLAYING...
            toggleMidiClock(); // Toggle the MIDI CLOCK off
        }
        CLOCKMASTER != CLOCKMASTER; // Only toggle the MIDI-CLOCK-MASTER boolean when chording its command with a regular key, to prevent chord collisions
        if (CLOCKMASTER && (!PLAYING)) { // If this is now in MASTER mode, and not PLAYING...
            toggleMidiClock(); // Toggle the MIDI CLOCK on
        }
    } else if (BOTCTRL == B00000111) { // If the SAVE chord is held...
        saveData(slice + (row * 8)); // Save this song to a save-slot corresponding to the slice keypress
    } else if (BOTCTRL == B00011100) { // If the LOAD chord is held...
        loadData(slice + (row * 8)); // Load a song from the save-slot corresponding to the slice keypress
    } else { // Else, if the keystroke was within the note-keys...
        PITCHOFFSET = (LEFTCTRL & 3) * 12; // Shift pitch-offset by 1, 2, or 3 octaves, based on the currently-held octave-keys
        PITCHOFFSET += (LEFTCTRL & 4) ? 5 : 0; // Shift pitch-offset by interval 5, if pressed
        PITCHOFFSET += (LEFTCTRL & 8) ? 3 : 0; // Interval 3, if pressed
        PITCHOFFSET += (LEFTCTRL & 16) ? 2 : 0; // Interval 2, if pressed
        byte pitch = ((4 - row) * 4) + (col - 1); // Get a pitch-value corresponding to the keystroke location
        byte velo = // Get a velocity value...
            max(1, min(127, // Bounded between 1 and 127, to make a valid MIDI NOTE-ON velocity-byte...
                VELOCITY // Of the stored global VELOCITY-value for RECORD-mode notes...
                + ( // Plus...
                    random(0, HUMANIZE) // A random HUMANIZE value within the user-defined range...
                    - byte(floor(HUMANIZE / 2)) // Minus half of the HUMANIZE range, to create an even negative-to-positive spread
                )
            ));
        if (RECORDNOTES) { // If RECORD-NOTES is active, and notes are being recorded...

            // TODO: put SD-card memory-write here

        }
        sendNote(CHANNEL, (OCTAVE * 12) + PITCHOFFSET + pitch, velo, DURATION); // Send the note, with the constructed pitch and velocity values
    }

}


// Interpret an incoming keystroke, using a given button's row and column
void assignKey(byte col, byte row) {
	if (row <= 4) { // If keystroke is in the top 5 rows...
		if (col == 0) { // If keystroke is in column 1...
            LEFTCTRL |= 1 << row; // Add the button-row's corresponding bit to the LEFTCTRL byte
		} else { // If keystroke is right of column 1...
			if (RECORDMODE) { // If RECORDMODE mode is active...
                recPress(col - 1, row); // Parse the RECORDMODE-mode button-press
			} else { // Else, if SLICE or OVERVIEW mode is active...
                slicePress(col - 1, row); // Parse the SLICE/OVERVIEW-mode button-press
            }
		}
	} else { // Else, if keystroke is in the bottom row...
        BOTCTRL |= 1 << col; // Add the button-column's corresponding bit to the BOTCTRL byte
        if (RECORDMODE && (BOTCTRL == B00000001)) { // If in RECORD mode, and the RECORD-NOTES command was pressed...
            RECORDNOTES != RECORDNOTES; // Toggle whether to record played notes into the top slice-sequence
        }
        if (BOTCTRL == B00001111) { // If the TOGGLE-RECORD-MODE chord has just been pressed...
            RECORDMODE = !RECORDMODE; // Toggle/untoggle RECORD MODE
            RECORDNOTES = false; // Disable note-recording, to avoid recording new notes automatically on a future toggle cycle
        } else if (BOTCTRL == B00010101) { // If the GLOBAL PLAY/STOP chord has just been pressed...
            toggleMidiClock(true); // Toggle the MIDI clock, with "true" for "the user did this, not a device"
        }
	}
}

// Interpret a key-release according to whatever command-mode is active
void unassignKey(byte col, byte row) {
    if (row == 5) { // If this up-keystroke was in the bottommost row...
        if (col == 0) { // If this is the leftmost button in said row...
            FLINGSEQ = 255; // Put an empty dummy-value into the FLINGSEQ slot, to prevent old partially-complete FLINGs from affecting later behavior
        }
        BOTCTRL &= ~(1 << col); // Remove keystroke's corresponding bit from the BOTCTRL byte
        updateGUI(); // Update the entire GUI
    } else if (col == 0) { // Else, if this up-keystroke was in the leftmost column...
        LEFTCTRL &= ~(1 << row); // Remove keystroke's corresponding bit from the LEFTCTRL byte
        updateGUI(); // Update the entire GUI
    }
}

// Parse any incoming keystrokes in the Keypad grid
void parseKeystrokes() {
	if (kpd.getKeys()) { // If any keys are pressed...
		for (byte i = 0; i < 10; i++) { // For every keypress slot...
			if (kpd.key[i].stateChanged) { // If the key's state has just changed...
				byte keynum = byte(kpd.key[i].kchar) - 48; // Convert the key's unique ASCII character into a number that reflects its position
				byte kcol = keynum % 5; // Get the key's column
				byte krow = byte((keynum - kcol) / 5); // Get the key's row
				if (kpd.key[i].kstate == PRESSED) { // If the button is pressed...
					assignKey(kcol, krow); // Interpret the keystroke
				} else if (kpd.key[i].kstate == RELEASED) { // Else, if the button is released...
					unassignKey(kcol, krow); // Interpret the key-release
				}
			}
		}
	}
}
