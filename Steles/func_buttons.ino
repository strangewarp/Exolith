
// Parse a slice-keypress that was generated while in SLICE or OVERRVIEW mode
void slicePress(byte col, byte row) {

    byte seq = 0; // Will hold the seq-index of whatever seq is being modified by the given command
    byte slice = 0; // Will hold the position of the slice that corresponds to the button that's been pressed
    if (BOTCTRL & B00000001) { // If the OVERVIEW-button is being held...
        seq = col + (4 * row); // Get the seq-index of the button's corresponding OVERVIEW-seq
        seq += 16 * (LEFTCTRL & B00000001); // If the RIGHT-SIDE key is held, add 16 to the seq value
    } else { // Else, if OVERVIEW isn't being held...
        slice = col + (4 * (LEFTCTRL & B00000001)); // Get the slice that corresponds to this column, plus 4 if RIGHT-SIDE is held
        seq = SLICE_ROW[row]; // Get the index of the seq in the given slice-row
    }

    if ((!BOTCTRL) && !(LEFTCTRL & B00011110)) { // If no control-buttons are being held (aside from, optionally, the RIGHT-SIDE button)...
        byte size = SEQ_SIZE[seq >> 1] >> (4 * (seq & 1)); // Get the size-value of the sequence
        size = size ? size : 16; // If the sequence's stored size-value is 0, treat it as 16
        SEQ_POS[seq] = 24 * size * slice; // Set the seq's position to correspond with the given slice-point
        SEQ_PLAYING[seq >> 3] |= 1 << (seq & 7); // Set the seq's PLAYING-bit to 1
    } else if (LEFTCTRL == B00000001) { // If the FLING button is held...
        if (FLINGSEQ == 255) { // If the FLINGSEQ slot hasn't been filled by a FLING keypress yet...
            FLINGSEQ = seq; // Put the given sequence into the FLINGSEQ slot
        } else { // Else, if the FLINGSEQ slot is filled...
            SLICE_SLOT[col] = FLINGSEQ; // Fill the SLICE_SLOT corresponding to the key's column with the seq in the FLINGSEQ slot
            FLINGSEQ = 255; // Set the FLINGSEQ slot to an empty dummy-value
        }
    } else if (BOTCTRL == B00000001) { // If only the OVERVIEW button is held...
        SEQ_CMD[seq] = 0; // Empty out whatever cued commands the sequence might have
        SEQ_POS[seq] = 0; // Set the seq's tick-position to correspond with the first slice-point, which is 0
        SEQ_PLAYING[seq >> 3] |= 1 << (seq & 7); // Set the seq's PLAYING-bit to 1
    } else if (BOTCTRL == B00000011) { // If the OVERVIEW-OFF chord is held...
        SEQ_CMD[seq] = 0; // Empty out whatever cued commands the sequence might have
        SEQ_POS[seq] = 0; // Reset the seq's tick-position
        SEQ_PLAYING[seq >> 3] &= ~(1 << (seq & 7)); // Set the seq's PLAYING-bit to 0
    } else if ( // If...
        (BOTCTRL == B00001000) // The CUE-1 button is held...
        || (BOTCTRL == B00001001) // Or the OVERVIEW-CUE-1 chord is held...
    ) { // Then...
        SEQ_CMD[seq] = B10000001 | (slice << 2); // Cue an ON for this seq's given slice, on the next global 1-beat
    } else if ( // If...
        (BOTCTRL == B00010000) // The CUE-8 button is held...
        || (BOTCTRL == B00010001) // Or the OVERVIEW-CUE-8 chord is held...
    ) { // Then...
        SEQ_CMD[seq] = B10000010 | (slice << 2); // Cue an ON for this seq's given slice, on the next global 8-beat
    } else if ( // If...
        (BOTCTRL == B00000110) // The OFF-SCATTER chord is held...
        || (BOTCTRL == B00000111) // Or the OVERVIEW-OFF-SCATTER chord is held...
    ) { // Then...
        SEQ_SCATTER[seq] = 0; // Reset the seq's SCATTER-data
        SEQ_OFFSET[seq] = 0; // Reset the seq's SCATTER-controlled tick-position offset
    } else if ( // If...
        (BOTCTRL == B00001010) // The OFF-CUE-1 chord is held...
        || (BOTCTRL == B00001011) // Or the OVERVIEW-OFF-CUE-1 chord is held...
    ) { // Then...
        SEQ_CMD[seq] = B00000001; // Cue an OFF for this seq, on the next global 1-beat
    } else if ( // If...
        (BOTCTRL == B00010010) // The OFF-CUE-8 chord is held...
        || (BOTCTRL == B00010011) // Or the OVERVIEW-OFF-CUE-8 chord is held...
    ) { // Then...
        SEQ_CMD[seq] = B00000010; // Cue an OFF for this seq, on the next global 8-beat
    } else if (BOTCTRL == B00000010) { // If the OFF button is held...
        SEQ_CMD[seq] = 0; // Empty out whatever cued commands the sequence might have
        SEQ_POS[seq] = 0; // Reset the seq's tick-position
        SEQ_PLAYING[seq >> 3] &= ~(1 << (seq & 7)); // Set the seq's PLAYING-bit to 0
    } else if (BOTCTRL == B00000100) { // If the SCATTER button is held...
        SEQ_SCATTER[seq] ^= 1 << slice; // Toggle the SCATTER-bit that corresponds to the given slice-button
    } else if (BOTCTRL == B00001100) { // If the BPM chord is held...
        BPM = max(20, BPM ^ (1 << slice)); // Set the BPM to a binary value corresponding to the keystroke, with a minimum of 20
    } else if (LEFTCTRL == B00000010) { // If the EXCLUDE button is held...
        byte sbin = 1 << slice; // Get this slice-press's binary value
        if (SEQ_EXCLUDE[seq] ^ sbin) { // If any open slices would remain after an EXCLUDE operation...
            SEQ_EXCLUDE[seq] ^= sbin; // Set the sequence's excluded slices to a binary value corresponding to the keystroke
            word slicewidth = 24 * (SEQ_SIZE[seq >> 1] >> (4 * (seq & 1))); // Get the number of ticks in a single slice within this seq
            word seqwidth = slicewidth * 8; // Get the total number of ticks within the seq
            while (true) { // Loop until reaching a break point...
                byte spos = byte(floor(SEQ_POS[seq] / (24 * SEQ_SIZE[seq]))); // Get the seq's tick-position's corresponding slice
                if (SEQ_EXCLUDE[seq] & (1 << spos)) { // If the slice holding the seq's tick-position isn't excluded...
                    break; // Break from the loop, as everything is fine
                } // Otherwise, do the following things:
                SEQ_POS[seq] = (SEQ_POS[seq] + slicewidth) % seqwidth; // Increase the tick-position by 1 slice worth of ticks, wrapped to the seq's size
            }
        }
    } else if (LEFTCTRL == B00000100) { // If the RANDOMIZE-SLICE button is held...
        SEQ_RAND[seq] = 1 << col; // Toggle the RANDOMIZE-SLICE bit that corresponds to the given column
    } else if (LEFTCTRL == B00001000) { // If the RANDOMIZE-VELOCITY button is held...
        SEQ_RAND[seq] = 1 << (4 + col); // Toggle the RANDOMIZE-VELOCITY bit that corresponds to the given column
    }

}

// Parse a note-keypress that was generated while in RECORDING mode
void recPress(byte col, byte row) {

    if (row == 5) { // If the keystroke was in the bottom row...



    } else if (col == 0) { // Else, if the keystroke was in the left column...
        RECPITCH = (LEFTCTRL & 3) * 12; // Shift record-pitch by octaves from octave-keys
        RECPITCH += (LEFTCTRL & 4) ? 5 : 0; // Shift record-pitch by interval 5, if pressed
        RECPITCH += (LEFTCTRL & 8) ? 3 : 0; // Interval 3, if pressed
        RECPITCH += (LEFTCTRL & 16) ? 2 : 0; // Interval 2, if pressed
    else { // Else, if the keystroke was in neither the bottom row nor the left column...



    }

}


// Interpret an incoming keystroke, using a given button's row and column
void assignCommandAction(byte col, byte row) {
	if (row <= 4) { // If keystroke is in the top 5 rows...
		if (col == 0) { // If keystroke is in column 1...
            LEFTCTRL |= 1 << row; // Add the button-row's corresponding bit to the LEFTCTRL byte
		} else { // If keystroke is right of column 1...
			if (RECORDING) { // If RECORDING mode is active...
                recPress(col - 1, row); // Parse the RECORDING-mode button-press
			} else { // Else, if SLICE or OVERVIEW mode is active...
                slicePress(col - 1, row); // Parse the SLICE/OVERVIEW-mode button-press
            }
		}
	} else { // Else, if keystroke is in the bottom row...
        BOTCTRL |= 1 << col; // Add the button-column's corresponding bit to the BOTCTRL byte
        if (BOTCTRL == B00001111) { // If the TOGGLE-RECORD-MODE chord has just been pressed...
            RECORDING = !RECORDING; // Toggle/untoggle RECORD MODE
        } else if (BOTCTRL == B00010101) { // If the GLOBAL PLAY/STOP chord has just been pressed...
            toggleMidiClock(true); // Toggle the MIDI clock, with "true" for "the user did this, not a device"
        }
	}
}

// Interpret a key-release according to whatever command-mode is active
void unassignCommandAction(byte col, byte row) {
    if (row == 5) { // If this up-keystroke was in the bottommost row...
        if (col == 0) { // If this is the leftmost button in said row...
            FLINGSEQ = 255; // Put an empty dummy-value into the FLINGSEQ slot, to prevent old partially-complete FLINGs from affecting later behavior
        }
        BOTCTRL &= ~(1 << col); // Remove keystroke's corresponding bit from the BOTCTRL byte
    } else if (col == 0) { // Else, if this up-keystroke was in the leftmost column...
        LEFTCTRL &= ~(1 << row); // Remove keystroke's corresponding bit from the LEFTCTRL byte
    }
}

// Parse any incoming keystrokes in the Keypad grid
void parseKeystrokes() {
	if (kpd.getKeys()) { // If any keys are pressed...
		for (byte i = 0; i < 10; i++) { // For every keypress slot...
			if (kpd.key[i].stateChanged) { // If the key's state has just changed...
				byte keynum = byte(kpd.key[i].kchar) - 48; // Convert the key's unique ASCII character into a number that reflects its position
				byte kcol = keynum % 5; // Get the key's column
				byte krow = byte((keynum - kcol) / 5); // Get the key's row
				if (kpd.key[i].kstate == PRESSED) { // If the button is pressed...
					assignCommandAction(kcol, krow); // Interpret the keystroke
				} else if (kpd.key[i].kstate == RELEASED) { // Else, if the button is released...
					unassignCommandAction(kcol, krow); // Interpret the key-release
				}
			}
		}
	}
}
