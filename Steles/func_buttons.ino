
// Parse a slice-keypress that was generated while in SLICE or OVERRVIEW mode
void slicePress(byte col, byte row) {

    byte seq = 0; // Will hold the seq-index of whatever seq is being modified by the given command
    byte slice = 0; // Will hold the position of the slice that corresponds to the button that's been pressed
    if ((BOTCTRL & B00000001) > 0) { // If the OVERVIEW-button is being held...
        seq = col + (5 * row); // Get the seq-index of the button's corresponding OVERVIEW-seq
        seq += 25 * (LEFTCTRL & B00000001); // If the RIGHT-SIDE key is held, add 25 to the seq value
    } else { // Else, if OVERVIEW isn't being held...
        slice = (col - 1) + (4 * (LEFTCTRL & B00000001)); // Get the slice that corresponds to this column, plus 4 if RIGHT-SIDE is held
        seq = SLICE_ROW[row]; // Get the index of the seq in the given slice-row
    }

    if (LEFTCTRL == B00000001) { // If the FLING button is held...
        if (FLINGSEQ == 255) { // If the FLINGSEQ slot hasn't been filled by a FLING keypress yet...
            FLINGSEQ = seq; // Put the given sequence into the FLINGSEQ slot
        } else { // Else, if the FLINGSEQ slot is filled...
            SLICE_SLOT[col] = FLINGSEQ; // Fill the SLICE_SLOT corresponding to the key's column with the seq in the FLINGSEQ slot
            FLINGSEQ = 255; // Set the FLINGSEQ slot to an empty dummy-value
        }
    } else if (BOTCTRL == B00000001) { // If only the OVERVIEW button is held...
        SEQ_CMD[seq] = 0; // Empty out whatever cued commands the sequence might have
        SEQ_POS[seq] = 0; // Set the seq's tick-position to correspond with the first slice-point, which is 0
        SEQ_PLAYING[seq >> 3] |= 1 << (seq & 7); // Set the seq's PLAYING-bit to 1
    } else if (BOTCTRL == B00000011) { // If the OVERVIEW-OFF chord is held...
        SEQ_CMD[seq] = 0; // Empty out whatever cued commands the sequence might have
        SEQ_POS[seq] = 0; // Reset the seq's tick-position
        SEQ_PLAYING[seq >> 3] &= ~(1 << (seq & 7)); // Set the seq's PLAYING-bit to 0
    } else if ( // If...
        (BOTCTRL == B00001000) // The CUE-1 button is held...
        || (BOTCTRL == B00001001) // Or the OVERVIEW-CUE-1 chord is held...
    ) { // Then...
        SEQ_CMD[seq] = B10000001 | (slice << 2); // Cue an ON for this seq's given slice, on the next global 1-beat
    } else if ( // If...
        (BOTCTRL == B00010000) // The CUE-8 button is held...
        || (BOTCTRL == B00010001) // Or the OVERVIEW-CUE-8 chord is held...
    ) { // Then...
        SEQ_CMD[seq] = B10000010 | (slice << 2); // Cue an ON for this seq's given slice, on the next global 8-beat
    } else if ( // If...
        (BOTCTRL == B00000110) // The OFF-SCATTER chord is held...
        || (BOTCTRL == B00000111) // Or the OVERVIEW-OFF-SCATTER chord is held...
    ) { // Then...
        SEQ_SCATTER[seq] = 0; // Reset the seq's SCATTER-data
        SEQ_OFFSET[seq] = 0; // Reset the seq's SCATTER-controlled tick-position offset
    } else if ( // If...
        (BOTCTRL == B00001010) // The OFF-CUE-1 chord is held...
        || (BOTCTRL == B00001011) // Or the OVERVIEW-OFF-CUE-1 chord is held...
    ) { // Then...
        SEQ_CMD[seq] = B00000001; // Cue an OFF for this seq, on the next global 1-beat
    } else if ( // If...
        (BOTCTRL == B00010010) // The OFF-CUE-8 chord is held...
        || (BOTCTRL == B00010011) // Or the OVERVIEW-OFF-CUE-8 chord is held...
    ) { // Then...
        SEQ_CMD[seq] = B00000010; // Cue an OFF for this seq, on the next global 8-beat
    } else if (BOTCTRL == B00000010) { // If the OFF button is held...
        SEQ_CMD[seq] = 0; // Empty out whatever cued commands the sequence might have
        SEQ_POS[seq] = 0; // Reset the seq's tick-position
        SEQ_PLAYING[seq >> 3] &= ~(1 << (seq & 7)); // Set the seq's PLAYING-bit to 0
    } else if (BOTCTRL == B00000100) { // If the SCATTER button is held...

    } else if (BOTCTRL == B00001010) { // If the OFF-CUE-1 chord is held...

    } else if (BOTCTRL == B00010010) { // If the OFF-CUE-8 chord is held...

    } else if (BOTCTRL == B00001100) { // If the BPM chord is held...

    } else if (BOTCTRL == B00010101) { // If the GLOBAL PLAY/STOP chord is held...

    } else if (BOTCTRL == B00011110) { // If the TOGGLE-RECORD-MODE chord is held...

    } else if (LEFTCTRL == B00000010) {




    } else if ((BOTCTRL == 0) && ((LEFTCTRL & 30) == 0)) { // If no control-buttons are being held (aside from, optionally, the RIGHT-SIDE button)...
        SEQ_POS[seq] = (96 * SEQ_LEN[seq]) * ((slice - 1) / 8); // Set the seq's position to correspond with the given slice-point
        SEQ_PLAYING[seq >> 3] |= 1 << (seq & 7); // Set the seq's PLAYING-bit to 1
    }



}

// Parse a note-keypress that was generated while in RECORDING mode
void recPress(byte col, byte row) {



}


// Interpret an incoming keystroke, using a given button's row and column
void assignCommandAction(byte col, byte row) {
	if (row <= 4) { // If keystroke is in the top 5 rows...
		if (col == 0) { // If keystroke is in column 1...
            LEFTCTRL |= 1 << row; // Add the button-row's corresponding bit to the LEFTCTRL byte
		} else { // If keystroke is right of column 1...
			if (RECORDING) { // If RECORDING mode is active...
                recPress(col - 1, row); // Parse the RECORDING-mode button-press
			} else {
                slicePress(col, row);
            }

            /*if ((BOTCTRL & B00000001) > 0) { // Else, if OVERVIEW MODE is active...
                slicePress(col - (1 + ((col - 1) >> 4)), row)
				slicePress(col, row, (5 * row) + col, 1); // Send a keypress for slice 1 of the sequence that corresponds to this overview-button
			} else { // Else, if SLICE MODE is active...
				slicePress(col, row, SLICE_ROW[row], (col + (4 * SLICE_SIDE[row])) - 1); // Send a slice-keypress for the seq's selected column
			}*/
		}
	} else { // Else, if keystroke is in the bottom row...
        BOTCTRL |= 1 << col; // Add the button-column's corresponding bit to the BOTCTRL byte
        if (BOTCTRL == B00001111) { // If a RECORD-MODE-toggling command has been activated...
            RECORDING = !RECORDING; // Toggle/untoggle RECORD MODE
        } else if (BOTCTRL == B00010101) { // If a GLOBAL PLAY/STOP command has been activated...
            toggleMidiClock(); // Toggle the MIDI clock, if applicable
        }
	}
}

// Interpret a key-release according to whatever command-mode is active
void unassignCommandAction(byte col, byte row) {
    if (row == 5) { // If this up-keystroke was in the bottommost row...
        if (col == 0) { // If this is the leftmost button in said row...
            FLINGSEQ = 255; // Put an empty dummy-value into the FLINGSEQ slot, to prevent old partially-complete FLINGs from affecting later behavior
        }
        BOTCTRL &= ~(1 << col); // Remove keystroke's corresponding bit from the BOTCTRL byte
    } else if (col == 0) { // Else, if this up-keystroke was in the leftmost column...
        LEFTCTRL &= ~(1 << row); // Remove keystroke's corresponding bit from the LEFTCTRL byte
    }
}

// Parse any incoming keystrokes in the Keypad grid
void parseKeystrokes() {
	if (kpd.getKeys()) { // If any keys are pressed...
		for (byte i = 0; i < 10; i++) { // For every keypress slot...
			if (kpd.key[i].stateChanged) { // If the key's state has just changed...
				byte keynum = byte(kpd.key[i].kchar) - 48; // Convert the key's unique ASCII character into a number that reflects its position
				byte kcol = keynum % 5; // Get the key's column
				byte krow = byte((keynum - kcol) / 5); // Get the key's row
				if (kpd.key[i].kstate == PRESSED) { // If the button is pressed...
					assignCommandAction(kcol, krow); // Interpret the keystroke
				} else if (kpd.key[i].kstate == RELEASED) { // Else, if the button is released...
					unassignCommandAction(kcol, krow); // Interpret the key-release
				}
			}
		}
	}
}
