

Tine TODO-ARCHIVE (to keep a record of already-finished tasks)

Software:

	. figure out why the savefile system defaults to file "04"
		-- loadPrefs() was missing a makePrefBuf() call, inside its "if (!sd.exists(pn)) ..." clause
		. check whether this fixes things
			-- seems to have fixed it

	-- found a UI bug: copyCmd had the wrong numerical value in KEYTAB[]

	. check whether there's an additional "MIDI Tempo" SYSEX command, or whether it's solely dictated by TEMPO TICK events
		-- yeah but it's a 4-byte SYSEX command. so...
		. change all sequencing mechanisms in the following ways:
			-- am doing
			. BPM command is now a 2-byte command, in the format of "240 x 0":
				. "x": the BPM value (bounded to 16-200)
					-- ok
			. change note-entry system to allow BPM commands to be entered
				-- done
			. when a BPM command is encountered by the sequencing mechanism, only change the internal BPM value; do not actually send anything to MIDI-OUT
				-- done
			. anything that checks for 2-byte or 3-byte commands, or command-type in general, needs to be double-checked for conflicts with the BPM command type
				-- ok

	-- also moved the MOUT_COUNT checking mechanism into parseTickContents(), since every BPM-CHANGE needs to be caught, regardless of how full MOUT_COUNT gets.
		-- this hypothetically slightly reduces performance, could revert it later if I need to

	-- updated chanCmd() to compensate correctly for the validity of command-values of 240
	-- updated upperBitsCmd() similarly

	. make the BPM command accessible through both PLAY MODE and RECORD MODE, with the same control-button chord
	.     (this is especially necessary so the user can compensate for blunders related to slicing into a bad BPM during a performance)
		-- am doing
		-- chord number: 010001 (in-code: 100010)
		. update button-key.txt
			-- done
		. change BPM's behavior in assignKey() et al
			-- am doing
			. for PLAY MODE
				-- done
		. change BPM's key-chord in RECORD MODE
			-- done
			. change command-lists in data_cmds.ino
				-- done
		. add a "BPM" indicator to the GUI for PLAY MODE
			-- done
		. change the "BPM" case in the GUI for RECORD MODE
			-- done
		. remove "todo update" entries from button-key.txt
			-- done

	. add "BPM" glyph to PLAY MODE's BPM command
		-- am doing
		. update TO_UPDATE flags in unassignKey() and parsePlayPress() to cover the bottom 6 rows as well
			-- done
		. update GUI parser in updatePlayBottomRows() to display the BPM-glyph when a BPM chord is held
			-- done

	-- fixed a one-off error for the "col" value in the call to tempoCmd() from parsePlayPress()
	-- fixed the manner in which updatePlayBottomRows() displays the TEMPO glyph when PLAY MODE's BPM command is held
	-- made the BPM sigil appear in PLAY MODE at all the correct times

	. unknown command-types in RECORD MODE need to set a TO_UPDATE flag for the bottom 6 rows (currently seems to only flag top row)
		-- fixed: it was a mismatched value in the KEYTAB array

	-- found and (probably) fixed a bug where all sequenced notes were acting like they had a duration of 0
	-- changed writeCommands() to correctly overwrite BPM-change commands
	-- fixed the ERASE WHILE HELD glyph to change its appearance depending on whether note-recording is active

	-- updated the MIDI-IN system to only call file.sync() once per tick max, to save on SD-card wear (still requires testing)
	-- increased the length of the BLINK that occurs on each QUANTIZE tick in RECORD MODE

	. change REPEAT so that held chords are recorded into TRACK 1 & 2 simultaneously
		-- done
	. in RECORD MODE, BLINK should only illuminate the half of the screen that corresponds to the current TRACK
		-- done

	-- made recording-blinks longer in RECORD-MODE
		-- tweaked the duration for this again

	. redesign the top LED-row in RECORD MODE:
		-- am doing
		. the quantize-tick should only be displayed in LEDs 5 and 6
			-- done
		. the currently-active TRACK should be displayed in LEDs 7 and 8
			-- done

	-- refactored the "flip number values into correct format" line in parsePlayPress()
	-- fixed a labeling mistake in button-key.txt
	-- removed superfluous parentheses from updateGlobalRand()

	. since the meaningful GUI signifiers for QUANTIZE and TRACK are now being handled by the BLINK system...
		. in RECORD MODE, change the top GUI row to only show the global-cue's current beat
			-- done
		. in PLAY MODE...
			. change the top GUI row to only show the global-cue's current beat
				-- done
			. if PAGE B is active, then invert the second GUI row's illumination
				-- done
		. change all TO_UPDATE calls related to these things
			-- done

	-- lightly refactored updateSecondRow()
	-- fixed some slight bad text-formatting in buttons-key.txt

	. add a QRESET command, which will reset QUANTIZE's anchor point every n ticks
		-- am doing
		. change the REPEAT system to make this distinction
			-- done
		. change all related BLINK and TO_UPDATE calls
			-- afaict done
		. change the prefs-file routines to add a QRESET slot
			-- done
		. change all relevant GUI calls
			-- done
		. add CmdFunc and glyph for QRESET
			-- done
		. add GUI routines for QRESET
			-- done

	. wipe the SD-card again before testing, since the prefs-file format has been changed
		-- ok

	-- added a blink effect whenever a note is played in RECORD-MODE, regardless of whether RECORDNOTES is armed

	. write a stripped-down replacement for LedControl, to save RAM space
		-- am doing
		. write "initialize" and "send line" functions
			-- done
		. change updateGUI() to open and close the MAX72** chip's data-latch on digital pin 6
			-- done
		. change all GUI-related functions to use sendRow() instead of LedControl calls
			-- done

	. new LED system doesn't work. figure out why
		-- figured it out: every row-send command must be surrounded by its own set of CS-pin latch commands. these are now in sendRow()
		-- also might have been that sendRow() requires "volatile byte" typing. this is mysterious. leaving it in to be thorough

	-- removed an extraneous PORTD call from maxInitialize()

	-- slightly lengthened the BLINK duration when a note-key is pressed in RECORD-MODE

	. GUI is non-responsive after powering back up. figure out why
		-- still not sure of the exact cause, but, fixed it by restructuring maxInitialize(), sendRow(), and creating sendMaxCmd()

	-- found and fixed a SCATTER bug in parseScatter() even though I'm not testing that yet
	-- added clarification to a readTick() call inside of getTickNotes(), since it could easily be mistaken for a SCATTER bug

	. QUANTIZE/QRESET don't hit the right ticks when containing unusual values. fix it
		-- am doing
		. seems to go out of whack specifically when QRESET is at a value lower than 32. what's causing this
			. wait... is this just the testing apparatus again, combined with some user error (selecting QRESET of 8 when I thought it was 16)?
			-- this is the third time this has happened
			-- horrible. horrible. the bug never existed in the first place

	-- fixed a glyph-display error for PLAY MODE's BPM command

	. in PLAY MODE, BPM conflicts with CUE-OFF
		. this means:
			. the PLAY MODE section of button-key.txt is actually reversed, except for the "BPM" entry. fix it
				-- done
			. the BPM command needs to be mirrored to (top-down) 100010
				-- am doing
				. update CmdFunc system for this
					-- done
				. update GUI routines for this in PLAY MODE and RECORD MODE
					-- done
			. the QRESET command, which takes up (top-down) 100010 in RECORD MODE, needs to be moved to (top-down) 010010
				-- am doing
				. update CmdFunc system for this
					-- done
				. update GUI routines for this in RECORD MODE
					-- done

	-- replaced other references to the outdated BPM keychord in func_gui.ino
	-- removed the BLINK event on any BPM modification in PLAY MODE, for UI consistency
	-- refactored BLINK and TO_UPDATE flags in parsePlayPress()

	. test: do the repositioned QRESET and BPM commands work right?
		-- yes
	. has OFF CUE 0 been freed up correctly?
		-- yes

	. change the BLINK system:
		. divide BLINK into BLINKL and BLINKR, which are decremented in the same way that BLINK is
		. (BLINKL and BLINKR will simplify the need to show notes playing on tracks in RECORD MODE)
			-- ok
		. rewrite func_timer.ino to decrement both BLINKL/R types simultaneously
			-- done
		. rewrite all BLINK commands to flag BLINKL, BLINKR, or both, depending on context
			-- done
		. rewrite GUI routines to remove situational cruft, and to instead follow BLINKL and BLINKR straightforwardly
			-- done

	. when RECORD MODE is active, and RECORDNOTES is unarmed, and REPEAT is not active,
	.     a BLINK should occur for every note playing on each of the two tracks within the seq
	. (this will allow users to quickly know which track a seq's notes are playing on, because nobody can be expected to remember that, and it gets frustrating)
		-- done

	. test GUI changes
		. RECORD MODE [blink on note presence by track]
			-- forgot to include a TO_UPDATE call after the BLINK-setting mechanism in parseTickContents()
			. test again. does it work?
				-- both inaccurate blink-timing, and incomplete blink-shape in UI
				. what's causing inaccurate blink-timing?
					-- incorrect manipulation of the contents of BLINKL/BLINKR in updateRecBottomRows()
				. what's causing incomplete blink-shape?
					-- incorrect manipulation of the contents of BLINKL/BLINKR in updateRecBottomRows()
		. BLINKs during REPEAT
			-- seem ok
		. RECORDNOTES flag's impact on BLINK style
			-- seems correct
		. BLINK's response to TRACK-switching
			-- seems correct
		. CUE commands in PLAY MODE
			-- seems fine

	-- removed the BLINKs from...
		-- completed CUE commands in PLAY MODE (parseCues()),
		-- PLAY MODE CUE-chord-presses (parsePlayPress()),
	-- ...as there will now be visual confirmation related to flashing seq-LEDs

	. add a SEQFLASH system to PLAY MODE, so that any seqs with pending CUE commands will blink in certain ways:
		-- am doing
		. already-active seqs blink ON and OFF every quarter-note:
			. add a CUE-checking routine that sets a TO_UPDATE flag in parseCues()
				-- done
			. add a rendering routine for this to updatePlayBottomRows()
				-- done
		. currently-OFF seqs blink every half-note
			-- ok
		. test this
			-- seems to work

	. the seq-flash, in PLAY MODE, is reversed chronologically. it should be on-off-on-off but that is reversed. fix it
		-- fixed

	. for seqs that are OFF and have a dormant CUE, a half-note-sized flash-cycle is too visually confusing in-the-moment. so...
		. make them both have quarter-note flash-cycles, but with reversed flash-timing
			-- done
			-- also changed the logic around the related TO_UPDATE call in parseCues() so it is activated on a quarter-note for every seq with a dormant-cue

	. flashing-seqs still read in a visually confusing way when both CUE and CUE-OFF seqs are flashing at the same time, especially at low tempo.
		. the only reasonable way to fix this would be...
			. update a seq-LED on the first and second 16th-note within each half-note, with currently ON and OFF seq blinking in opposite ways
				-- done

	. needs to be a MIDI PANIC on startup, to compensate for any accidental power-cycles in the middle of SUSTAINs
		-- done

	. do sequences FLASH when they are empty and receive a CUE-OFF command?
		-- yes
		. should something be done about this?
			-- probably
			. cut this out at the source: don't let CUE-OFF commands get applied to already-off seqs
				-- done

	-- removed the first sendRow() from midiPanic(), since the first series of "ALL NOTES OFF" commands is too quick to be visible

	. move CUE button to second-bottommost row, and shift the 1-2-4 buttons upwards by 1 row?
	. (seems like this would be more intuitive UI - "off" and "cue" are used in concrete ways, whereas the numbers are used in abstract ways)
		. change all "CUE, 1, 2, and 4"-button-related entries in the PLAY MODE section of button-key.txt
			-- am doing
			. change most PLAY MODE-related commands
				. go through the codebase looking for everything related to a PLAY MODE keypress and updating as necessary
					-- done
			. change BPM command (again)
				. BPM: (top-down) 110000
					-- changed its entries in buttons-key.txt
					-- changed its CmdFunc entry

	. mystery crash after allowing RECORD MODE to sit for a while. figure out what it is
		-- no idea. hopefully the recent increase in free RAM will stop this type of weird event from happening

	. test all updated command-chords
		-- BPM-command doesn't work in PLAY MODE
		. fix it
			-- fixed: forgot to update the command-chord for BPM-presses in assignKey()

	. when notes are being entered with REPEAT active, the note gets retriggered twice on the entry-tick. this is bad. fix it
		-- fixed it by inserting an if-then-return clause at a specific point in processRecAction()
	. test the fix
		-- seems to work correctly

	. test changes:
		. is BLINK affected by the active TRACK in RECORD MODE?
			-- yes
		. do QUANTIZE and QRESET both work correctly...
			. in the GUI?
				-- yes
			. in regular note-entry?
				-- seems so
			. in REPEAT-based note-entry?
				-- yes
		. does REPEAT record held chords, but with recording otherwise acting monophonically?
			-- yes
		. how many notes are actually played when more than 2 are held with REPEAT active?
			-- always 2, which is reasonable

	-- removed redundant if-then statements for SCATTER behavior in parsePlayPress()
	-- changed assignKey() and unassignKey() so their BPM-and-SHIFT-checking routines are collapsed into a single external function: refreshPlayCustoms()
	-- clarified that SHIFT RECORDING POSITION works differently, and serves a different purpose, from SHIFT CUE
	-- fixed an outdated TO_UPDATE-checking line in parseRawMidi()

	. add a SHIFT GLOBAL CUE command, to shift the position of the global cue-point forward or backward by one step in PLAY MODE
		-- am doing
		. allocate a command-chord in buttons-key.txt
			-- done
		. add a clause to the PLAY MODE keypress routines
			-- done
			. should change the global CUR16 value, but not any seqs' POS values
				-- ok
		. add a standalone GUI-GLYPH for SHIFT
			-- done
		. add a GUI-routine to display the glyph
			-- done
		. test it by itself, particularly going over every possible off-by-one case
			-- fixed a bug where the SHIFT glyph was being loaded from PROGMEM wrong, due to an offset "i" var in updatePlayBottomRows()
			-- seems fine
		. test it with various cued-commands active in various sequences
			-- freezes during certain OFF-cmd configurations
			. figure out what's going on
				-- freezes occur when SHIFT is held while a sequence is in CUE-OFF state, but only sometimes
				. what is happening specifically?
					-- could be that the other if-then checks in parsePlayPress() are screwing with something somehow
					. fix the spaghetti-code there
						-- ok
					. mash the various crash-related commands again for a while: find any more crashes now?
						-- yes: sometimes the CUR16 point seems to stop advancing, when SHIFT is being held, during certain CUE-commands...
						-- ... but it doesn't seem to be an easily-replicable bug for some reason
	. SHIFT debugging cont'd:
		-- seems related to: shifting the cue forward by 1(16) while one or several sequences have CUE-OFF 0 in their CUE-value.
		-- ...at which point, the CUR16 stops advancing(?!)
		. figure out what to do
			-- changed "char" to "int" in the CUR16-updating line in parsePlayPress()
			. are there still crashes now?
				-- tentatively, I am not finding any
	. also encountering a bug related to the SHIFT-freeze bug, where LEDs will seem to be pulling partially-formed glyphs from memory in PLAY MODE
		-- this seems to have gone away as well

	. double-check: can the CHAN byte's upper bits only be changed by the UPPER CHAN BYTES command, as they should?
		-- yes

	-- updated some BPM-manipulation routines to use BPM_LIMIT_LOW and BPM_LIMIT_HIGH instead of hardcoded limit values
	-- changed the BLINKL/BLINKR calls in processRecAction() to add their values to whatever other BLINK values might be present
	-- fixed the entry of BPM-commands in processRecAction() so that they would correctly apply the same recorded HUMANIZE-modded-VELO to the current BPM
	-- writeCommands() was comparing saved BPM commands to the global BPM var, instead of the value that was actually passed to the function. fixed this

	. on every MIDI-OUT, look through the SUSTAIN system for the same note on the same channel, and if it is present, send a NOTE-OFF before the NOTE-ON
	. (this will allow certain synths to obey conflicting QUANTIZE and DURATION settings without wigging out)
		-- had to also apply this mechanism to MOUT, to prevent weird effects from duplicate notes on the same tick
		-- subsequently had to refactor the SUSTAIN and MOUT systems

	. add global SWING values, set per-song like BPM
		. create SWING GRANULARITY and SWING AMOUNT vars
			-- done
		. crate a SWING SECTION var, to track which section of swing is currently active
			-- done
		. change savefile format in data-format.txt to add SWING values for every save-slot
			-- done
		. change all file-read and write calls, to compensate for the presence of the new SWING-value bytes within each save-slot
			-- changed FILE_BYTES. also noticed that FILE_BYTES was originally a few bytes too small, which means the program would have had horrible bugs trying to access the last notes in the end of the last sequence. yikes! fixed it while changing FILE_BYTES
			-- updated define-statements to hold more characteristics of savefiles
			-- done, afaict
		. change file-load to put the file's SWING values into the global SWING vars
			-- done
		. change RECORD-MODE TOGGLE so that:
			. the SWING values are saved alongside the BPM value
				-- done
			. SWING PART is reset to 0 on every toggle between RECORD-MODE and PLAY-MODE
				-- done: I put this into resetAllTiming()
		. create entries in buttons-key.txt for SWING commands in RECORD MODE
			-- done
		. create CmdFunc entries for SWING GRANULARITY and SWING AMOUNT
			-- ok
			. when SWING GRANULARITY is changed, SWING SECTION should be checked against the new section-size and changed accordingly
				-- ok: a new function called updateSwingPart() does this now
		. create glyphs for SWING GRANULARITY and SWING AMOUNT
			-- done
		. edit CmdFunc apparatus to compensate for the presence of new glyphs
			-- done
		. shift other manual glyph calls in func_gui.ino (BPM/TEMPO glyph)
			-- done
		. on GUI for SWING-AMOUNT: top row should fill its left side for pre-swing, and fill its right side for post-swing, up to -64/+64 on respective sides
			-- done (definitely needs testing)
		. update top-row GUI for SWING-GRANULARITY
			-- done
		. change timing routines to compensate for SWING
			-- am doing
			. split TICKSIZE into "TSIZE1" and "TSIZE2" vars, to hold values equal to each side of the current SWING-amount in microseconds
				-- done
			. update every function that references TICKSIZE
				-- done
			. update TICKSZ1 and TICKSZ2 on every SWING AMOUNT change
				. for manual SWING AMOUNT via CmdFunc
					-- done
				. for automatic SWING AMOUNT via sequenced SWING GRAN commands
					-- done
		. change sequencing functions to incorporate SWING commands
			-- am doing
			. limits of the upperChanBits CmdFunc should now be 96 - 224, and any value below 128 should wipe the *lower* chan bits automatically
				-- ok
				. update sequenced/saved BPM commands to occupy a command-byte value of 112
					-- done
				. update the CmdFunc for UPPER CHAN BYTES to accomodate the new command-byte value-range
					-- done
				. update all sequencing routines that check for any kind of command-byte number
					-- done afaict
			. command-entry in RECORD MODE
				-- done afaict
			. sequencing in PLAY MODE
				-- done afaict
		. call updateSwingPart() after updating CUR16 in the timer func
			-- done
		. writeCommands() should recognize SWING commands in its wear-reduction mechanism
			-- done

	-- split updateTimer() into 4 smaller functions: updateTimer(), blinkDecay(), advanceTick(), and activateStep()

	. meticulously check that updateTimer() can handle situations where the micros-since-last-tick is many times greater than the micros-to-next-tick value
		-- seems ok: uses "if" instead of "while", relying instead on the main-loop itself
		. also make sure that it won't run many iterations of iterateAll() in such a situation without re-checking, because SWING may change back around
			-- aye, see above

	-- refactored the functions in func_timer.ino, and moved the KEYELAPSED-checking mechanism from advanceTick() to scanKeypad() (in func_keypad.ino)
	-- removed duplicate TODO entries for the SWING system
	-- changed SAMOUNT's top-row GUI to use the same visual shorthand as RPTSWEEP's - namely, using a virtual-char-display for its byte-value

	. wipe the testing SD-card again, due to savefile format changes
		-- done

	. tempo seems slightly too slow. re-check BPM/SWING algorithms
		-- it was just the default BPM value being lower than I expected, I think
		-- changed default savefile BPM value from 80 to 100

	. add a RPTSWEEP var to RECORD MODE: this will cause any REPEAT command to store its velocity in the RPTVELO var
		. make a CmdFunc table entry for REPEAT-SWEEP, and update all other subsequent CmdFuncs in the list
			-- done
		. make the CmdFunc itself
			-- done
		. make a GUI-glyph for REPEAT-SWEEP
			-- done
		. update top-row to show negative/positive REPEAT-SWEEP values, using the same algorithm as the display for SWING-AMOUNT
			-- done
		. update manual call to BPM-glyph in func-gui to compensate for the new REPEAT-SWEEP glyph's presence
			-- done
		. subsequent REPEAT-triggers during the same keypress will change RPTVELO by the RPTSWEEP amount, and play/record at that velocity
			-- done
		. on any new note-button keystroke when REPEAT is enabled, RPTVELO should be set equal to VELO
			-- done
		. if REPEAT is enabled, then the HUMANIZE process should be based on RPTVELO instead of VELO
			-- ok
			. after a given REPEAT is processed, make sure RPTVELO has stored a raw reduced-RPTVELO velocity, not a velocity modulated by HUMANIZE for recording
				-- logic-flow seems correct for this

	-- moved updateTickSize() to func_timer.ino
	-- changed the name of "BPM_TABLE" to "MCS_TABLE"
	-- removed individual-note-offs from midiPanic(), since they're mostly-extraneous and cause a lot of startup lag

	. when a BPM command is activated in PLAY MODE, this primed the RECORDSEQ with an awkward and wrong value. fix it
		-- done: changed parsePlayPress() to check for PAGE-OFF, SCATTER, SCATTER UNSET, PAGE SCATTER UNSET, PAGE, SHIFT, and BPM

	-- changed the defaut position of RPTSWEEP so it sits at 128, which is its "middle" value
	-- added firmware-update process to tutorial-outline

	. test SWING modification
		-- horrible: changes in SWING value are erroneously changing the apparent tempo
		-- this seems to be at its worst when SWING AMOUNT is at or just below either 63 or 127
		. figure out what's going on
			-- updateTickSize()'s algorithm seems wrong
			. fix it
				-- having trouble finding the root of the problem:
				-- it looks like a problem with how TICKSZ1/TICKSZ2 are being interpreted, but there's nothing to be interpreting them the wrong way...
				-- ...which implies that the problem is in updateTickSize(), but the problem does not map to what could be being caused by that algorithm
				. continue looking and testing
					-- might've fixed it, after drawing some diagrams and rewriting the algorithm again
					-- found further bugs after mentally modeling the algorithm, and changed things around to correct for them
					. test it
						-- still not working. but: some testing-code has revealed that the TICKSZ1&2 vals are indeed being set correctly
						-- therefore: the problem is somewhere in the timing routines that *interpret* the TICKSZ vars
						. find the problem
							-- testing-code indicates that updateSwingPart() is staying at a value of 0 for some reason
							-- it can't be updateSwingPart(). however...
							-- SGRAN was being set to 0 on file-load, because createFiles() didn't have any commands to fill the stored SGRAN and SAMOUNT values
							-- so, added those commands to createFiles().
							. wipe SD-card again
								-- ok
							. test SWING for basic functionality again
								-- basic functionality achieved
			. re-test SWING-modification with notes, after applying fixes
				-- am doing
				. test with non-recorded-notes in RECORD MODE
					-- seems to work
				. test with plain recorded-notes
					-- seems to work
				. test with REPEAT
					-- it works
		. SWING-AMOUNT's GUI is off by one, on its negative side. fix it
			-- fixed
			-- this also fixed a related bug in REPEAT-SWEEP's GUI, which also relied on sendVirtualCharRow()

	. when two REPEAT-notes are being recorded/played in RECORD MODE, both sides of the screen should be covered by BLINK, not just one
		-- fixed: changed processRecAction() to use the given "trk" value, rather than the global "TRACK" value, when assigning BLINK-sides

	. BPM values are sometimes set to 255 on startup, when the SD-card hasn't been used for a while. figure out why
		-- no idea why. hmm...
		. figure out what to do
			-- I've put in a restart-function that gets called whenever the loaded BPM is 255.
			-- a do-while loop doesn't work here for whatever reason, but afaict, a total restart of the device fixes the problem.
			-- therefore, since the bug occurs on startup, and is relatively rare, calling a restart-function is the least-bad option to compensate for it.
			-- the bug itself seems to be some horrendous deep-wizard situation with the SD-card displaying unusual behavior that's impossible to replicate.
			-- but since it's a specific bug, with a specific unusual behavior that's always the same, the restart-function should take care of it.

	. change all DURATION-related routines to treat DURATION as a byte with boundaries of [0 to 129]
		-- done
	. change GUI routines to display DURATION's new properties (on 129, entire top-row should be lit)
		-- done
	. rewrite note-entry system in RECORD MODE:
		. add clause to processRecAction(): if DURATION is set to 129, and REPEAT is active, then use the QUANTIZE-size for the note's duration
			-- done
		. add clause to genericCmd(): if DURATION is set to 129, and REPEAT *isn't* active, then...
			-- done
			. when a note-key is pressed, or a MIDI-IN NOTE-ON is received:
				. [function setKeyNote(pitch, velo) should be created for the following:]
					. [function setRawKeyNote(pitch, velo) should be created for the following:]
						. play a NOTE-ON for the note
							-- ok
						. flag byteKEYFLAG (this will be necessary in case a control-column button is pressed while the note-button is held)
							-- ok
						. store in wordKEYPOS: the tick within the active seq where the keystroke occurred (offset by QUANTIZE)
							-- ok
						. store in byteKEYNOTE: the note-value corresponding to the button-press
							-- done
						. store in byteKEYVELO: the velocity-value corresponding to the button-press
							-- done
						. set byteKEYCOUNT to 0
							-- done
						. set current TRACK to BLINK
							-- done
					. modKeyPitch(): make note-modulation from processRecAction() into a new function, called by both processRecAction() and setKeyNote() [for KEYNOTE]
						-- done
					. modVelo(): make velo-modulation from processRecAction() into a new function, called by both processRecAction() and setKeyNote() [for KEYVELO]
						-- done
			. if a new note-key is pressed (or a new MIDI-IN NOTE-ON is received) while KEYFLAG is still flagged:
				. call recordHeldNote() for the current KEYNOTE and setKeyButton() for the new KEYNOTE
					. make sure this applies to:
						. MIDI-IN
							-- yes
						. keystrokes
							-- yes
				-- done
			. on every tick:
				. if KEYFLAG = 1...
					. increase KEYCOUNT by 1
						-- ok
					. if KEYCOUNT == 128...
						. call recordHeldNote()
							-- ok
				-- done
			. if a new control-button is pressed:
				. call recordHeldNote() for the current KEYNOTE (this prevents any conflicts)
					-- done
			. when a note-key is released, or a MIDI-IN NOTE-OFF is received:
				. if KEYFLAG is flagged...
					. and if modKeyPitch(BUTTON) corresponds to the key that has been released...
						. [function recordHeldNote() should be created for the following:]
							. send a NOTE-OFF
								-- ok
							. if RECORDING is currently ARMED...
								. call recordToSeq() with the reconstructed note-information, from NewPosition, NewDuration, KEYNOTE, KEYVELO
									-- done
								. set current TRACK to BLINK
									-- done
							. reset KEYFLAG
								-- done
				-- done
		. rewrite every other recordToSeq() call, to call the function with a DURATION value, since the funtion had to be rewritten to take a given duration
			-- done
		. on mode-toggle:
			. if KEYFLAG is flagged (even if a control-column button is held)...
				. call recordHeldNote()
					-- done

	. allow new songs to be loaded seamlessly
		. loading should display its number-glyph without pausing the entire sequencer
			-- ok
		. if any sequences are still active when a song is loaded, then their activity should persist on load (though their position should reset)
			-- done
		. sustains should NOT be halted on load
			-- done
		. cued commands should be CLEARED on load
			-- done
		. sequence positions should be WRAPPED on load
			-- done
		. needs an extra GUI tracking var, to display the file-number on the screen for half a second after loading, rather than being gated behind a delay()
			-- done

	-- the "restart-function" solution to the rare on-startup BPM bug just results in an infinite restart-loop
		-- so: I have replaced it with a function that just sets erroneous BPMs to a default value,
		-- and then throws a glyph to screen, to indicate that this is what has occurred.
			-- this is not ideal, but since this bug only occurs on startup, it should not happen during performance,
			-- and should be obvious if it happens during setup.
	-- updated this to make the invalid-BPM warning blink, and stick around for 2 seconds

	-- removed all manual "extern" compile-commands, since newer versions of Arduino seem to have made those superfluous

	. add a GRID-CONFIGURATION command, to rotate the button-grid's note-entry positions
		. update buttons-key.text
			-- done
		. add it to the CmdFunc list, and update the rest of the CmdFunc entries to compensate
			-- done
		. add a CmdFunc that toggles GRIDCONFIG (in func_cmds.ino)
			-- done
		. add a sigil for GRIDCONFIG (in data_gui.ino)
			-- done
		. add top-row case for displaying GRIDCONFIG status (in func_gui.ino)
			-- done
		. offset direct reads of other glyphs' memory-positions (BPM glyph, in func_gui.ino)
			-- done
		. update PREFS-file, and all related functions, to save GRIDCONFIG to P.DAT and also to read it correctly
			-- done
		. wipe SD-card again, because P.DAT's format has been updated
			-- done
		. test the two different GRID-CONFIGs
			-- they work

	-- increased LOADHOLD's decay-time to 18000
	-- added RPTVELO to P.DAT
	-- added RPTSWEEP to P.DAT as well (forgot to do this)

	. wipe SD-card and update firmware again, due to forgetting to add RPTSWEEP to P.DAT
		-- done
		. give file-creation and file-load another cursory test
			-- seems to work

	. test the new manual-duration system:
		. does it work straightforwardly?
			-- no: note-offs aren't being sent on key-release, and are only being sent on duration-timeout
			. figure out what's up
				-- modKeyPitch() had badly-ordered args in some calls. brought them in line with standard [col, row] ordering
				. re-test
					-- still having the same bug, somehow.
					. figure it out
						-- unassignKey() needs to subtract 1 from "col" before it works correctly in modKeyPitch(). fixed
		. does it cooperate with auto-durations?
			-- seems to
		. does mashing of multiple keys in manual-mode have the expected outcome? (many tiny notes plus one regular note for the last button hit)
			-- seems to
		. does it cooperate with REPEAT?
			-- notes with manual-duration are triggered on REPEAT ticks as though they have a duration of 128. this is wrong
			. figure out what's going on
				-- in processRecAction(), when RECORDNOTES wasn't armed, regular NOTE-ONs were playing with a duration of "DURATION" rather than "QUANTIZE"...
				-- ...this has now been fixed
		. does it record into a sequence coherently?
			-- yes
			. do clusters of keymashes also record into sequences coherently?
				-- seem to
			. does REPEAT-mode still record notes into sequences coherently?
				-- seems to
				. what about when DURATION is in manual-mode? do notes have the default QUANTIZE value for their duration when recorded?
					-- seem to
		. does hitting a control-column key cut off the held note-button?
			-- yes
			. does its note get recorded only when RECORDNOTES is armed, and not any other time?
				-- yes
			. do notes get cut off and recorded after becoming 128 ticks long, only when RECORDNOTES is toggled?
				-- yes
		. does mode-toggle cut off the held note-button and record its note?
			-- this is a subset of "hitting a control-column key", so logically absolutely yes

	. test changes to the timing system
		-- doing
	. is the newly-moved BPM-glyph still displaying right?
		-- yes
	. re-test the SUSTAIN and MOUT systems:
		-- am doing
		. percussion usage-case
			-- is not sending recorded notes for some reason
			. figure it out
				-- fixed: the second while-loop in removeDuplicates() was removing the MOUT-queue entry for the note it was checking
		. synth usage-case:
			. sustains
				-- seems fine
			. chords
				-- seems fine
			. z-fighting
				-- seems to compensate for this well
		. overloaded usage-case: >8 active SUSTAINs
			-- seems okay
		. overloaded usage-case: >8 MOUTs on the same tick
			-- seems okay
		. special case: multiple duplicate notes on the same tick:
			. in RECORD MODE:
				. same note on both TRACKs within the same seq
					-- seems ok
			. in PLAY MODE:
				. same note in two separate seqs
					-- seems fine
				. same note on both tracks, in multiple separate seqs
					-- seems fine

	-- set the default GRIDCONFIG back to 0
	-- changed the BLINK settings in activateStep() to blink both sides of the screen when RECORDNOTES is armed, but with a longer BLINK on the active TRACK's side
	-- changed recBlink() to use global TRACK instead of a given "trk", since its context in processRecAction() now also uses global TRACK rather than a given "trk"

	. when REPEAT is active, held note-chords should arpeggiate, rather than recording into separate tracks (the latter behavior is unintuitive and finicky in-practice)
		-- am implementing
		. add an ARPNEXT var, which tracks the next arpeggiation-note to play from within the ARP array on the next REPEAT-tick
			-- done
		. on every key-release when REPEAT is active, ARPNEXT should be reduced by 1 if a key "underneath" it is released, to keep the arpeggiation on-track
			-- ok
		. ARPNEXT should be set to 0, and ARP emptied, when any col=0 keypress is done in RECORD-MODE (check whether ARP[0] exists before clearing ARP, though)
			-- done
		. when DURATION=129, arpeggiation should not occur
			-- ok
		. otherwise, arpeggiation should happen at the QUANTIZE rate
			-- ok
	. when REPEAT is active, multiple held notes should NOT record into both tracks: this is too finicky in practice
		-- ok

	-- the arpeggiator was being buggy, finicky, and awful, so I totally rewrote it using a different and superior technique
	-- rewrote GRIDCONFIG, and all functions that translate buttons into notes, to store multiple grid-configurations in PROGMEM, and to translate buttons to notes
	-- changed updateGlobalRand() into xorShift(), which now takes a pointer to the random-word that is to be updated

	-- added arpModeCmd(), its corresponding CmdFunc, and its corresponding GUI routines, since I forgot to do that
	-- compensated for new glyph-presence by offsetting the manual access of the BPM-glyph in updatePlayBottomRows() again
	-- added top-row GUI for ARP-MODE as well (oops)

	-- in assignKey(), clarified pgm_read_word() into pgm_read_word_near

	. test arpeggiation:
		-- borked: plays only very low notes for some reason
		. figure out what's wrong
			-- parseRepeats() wasn't applying OCTAVE to the raw held-note. fixed
			. however:
				. both UP and DOWN arpeggiation get stuck on their initial note. figure out what's wrong
					-- original algorithm was throwing false-positives. rewrote entire algorithm
					. test it
						-- still seems to get "stuck" on notes, usually the first-pressed note
						. figure out what's going on
							-- I'm an idiot: was editing arpPress() while thinking it was arpAdvance() for some reason
							. fix everything
								-- rewrote the right algorithm this time.
								-- also: applied a GRIDCONFIG-conversion to the "repeating-random" ARPMODE's algorithm inside arpAdvance()
								. test the things again:
									. up-arpeggiation
										-- seems to work, but: partially corrupted GRIDCONFIGs are being applied only when REPEAT is active. even on single notes.
										. figure out what's causing this
											-- all notes above absolute-button-position 16 get converted into the note at position 15, regardless of GRIDCONFIG
											-- I can tell this happens in the GRIDCONFIG conversion-process because: the arpeggiation-system isn't duplicating them
											-- so: what the living hell is going on???
											-- (todo contents note: too many tabs. returning to baseline)
		. from immediately above: what the hell is going on
			-- it was a type error: in func_arp.ino, in the "if (nbuts << (1 << i))" lines, "1" should have been "1UL". this has now been fixed.
			. test up/down arpeggiation
				-- seems to work fine now
		. when several notes are pressed simultaneously, the first note is always the second-from-bottom note, rather than the bottom note. fix it
			-- fixed this by adding a simple ARPLATCH variable, which tracks whether any notes in the current keystroke-cluster have been played yet
		. does it drop old notes when released?
			-- yes
		. does it stay on-track when a single note is released?
			-- yes
		. are all the correct held-notes still playing when a single note is released?
			-- seems like it

	. REPEATING-RANDOM arpeggiation seems to be applying itself nonrandomly to most button-chords. fix this
		-- rewrote REPEATING-RANDOM algorithm.
		. test it
			-- still doesn't work
			-- restructured logic in all func_arp.ino funcs
		. test again
			-- still not working
			-- rethinking this prospect: is there much value to specifically *repeating* random?
			-- no
			. restructure arp funcs so "random" is just plain-random
				-- done
		. test again
			-- it works

	. ARPMODE should be saved to the prefs-file
		-- ok
	. wipe SD-card again
		-- ok
	. test whether ARPMODE is saved and loaded correctly
		-- seems to be fine

	-- changed the second-LED-row in RECORD MODE to have a blink-based effect when a large seq's LED-wrapping would fill the entire row
	-- rSweepCmd() could only be set to negative REPEAT-SWEEP values. fixed this

	. create a new user-toggleable var, ARPREFRESH, to control whether RPTVELO only gets reset when ARPLATCH equals 0
		-- done
		. update the sequencing process that refreshes RPTVELO, and make the refresh-behavior dependent on the ARPREFRESH flag
			-- done
		. write an arpRefCmd() function, which changes the state of ARPREFRESH
			-- done
		. make a CmdFunc entry for ARPREFRESH, and reposition all other CmdFuncs
			-- done
		. update func_gui.ino for the ARPREFRESH's top-row stuff, and to update that one manual call to a glyph's position (the BPM glyph)
			-- done
		. save ARPREFRESH to the prefs-file
			-- done
		. change prefs-file-related functions again
			-- done
		. wipe SD-card again
			-- ok
		. test ARPREFRESH functionality
			-- seems to work

	-- removed below-60 BPMs, to head off the possibility of type-conversion weirdness in lowest BPMs, which would likely not be used anyway
	-- removed the commented-out typedef for writeCommands() in Steles.ino, since it's definitely unnecessary now, and I'd forgotten about it
	-- refactored blinkDecay() by turning some duplicate-code into the new blinkReduce() function
	-- moved updateSwingPart() from func_sequencing.ino to func_timer.ino

	. is tempo actually being clocked at the right speed?
		. test with a MIDI-IN apparatus that measures actual BPM from TEMPO ticks
			-- hmm...
			. try treating each quarter-note as a "beat", which is usually the standard. Like: BPM -> Quarter-Notes Per Minute
				-- this seems more reasonable
				. ack: tempo freaks out above 200. figure out why
					-- forgot to add tempo consts for BPMs of 201-255. fixed
				-- also: changed upper BPM limit to 255
	. change everything to have a base granularity of 32nd-notes
		-- done
	. change boundaries of CmdFuncs to deal with 32nd-note granularity, rather than 16th-note
		-- done
	. halve max seq length in beats, across the board
		-- done by default
	. change SWING GRANULARITY:
		. base granularity of 16ths, not 8ths
			-- done
		. update SGRAN's GUI top-row element for RECORD MODE
			-- done
	. test everything after the 32nd-note granularity changes have been made
		-- am doing
		. RECORD-MODE:
			. QUANTIZE
				-- seems fine
			. QUANTIZE-RESET
				-- seems fine
			. note-recording
				-- seems to work
			. note-recording with REPEAT
				-- seems to work
			. note-recording with arpeggiation
				-- seems to work
			. SWING GRANULARITY
				-- this works, but...
				. certain SWING AMOUNT values are causing SWING to be computed wrong.
				. this is probably because TICKSZ1 and TICKSZ2 are being kept as words instead of floats...
				. fix this in every function that interacts with them
					-- done
				. test again
					-- seems to work now
		. PLAY-MODE:
			. sequence playback
				-- seems fine
			. CUE
				-- seems fine
			. beatslicing
				-- seems fine

	-- added a "sendClockReset()" call to the end of setup(), to boot up the timing mechanisms of downstream MIDI-CLOCK devices on startup

	. simplify: instead of GESTURE system, just have 5-to-6-button keychords for its commands
		-- am doing
		. GLOBAL PLAY/STOP and TOGGLE LOAD-MODE should both require an additional button-press while their keys are held...
		. ...so, check for them in the main "else" case inside of assignKey(), and trigger the commands' consequences from there
			-- ok
	. remove all subsequent GESTURE-related TODOs
		-- done
	. remove the PLAYING var, and the GLOBAL PLAY/STOP mechanism
		-- done
	. instead of toggling PLAYING on or off, introduce a RESET TIMING command. this should be fused with resetAllTiming(), and it should:
		-- ok
		. reset GLOBAL CUE
		. reset all seq-positions
		. NOT reset all pending cues (would be more useful this way, in weird performance-cases)
		. send a CLOCK STOP command
		. send a SONG-POSITION POINTER
		. send a CLOCK START command
			. plus a dummy-CLOCK-tick? research this again
		-- ok
	. remove all CLOCK-IN mechanisms, and all PLAYING and DUMMYTICK mechanisms
		-- done
	. shift around RECORD-MODE command-chords to fill the void left by the removal of CLOCKLEAD
		-- done
	. re-test changes to the sequencing system
		-- seems fine
	. test RESET TIMING for internal uses
		-- am doing
		. glyph doesn't show up, because I forgot to put one in
			-- fixed
		. re-test RESET TIMING
			-- button-presses aren't throwing up the right glyph
			. fix them
			-- fixed
		. test RESET TIMING again
			-- seems to work
	. test RESET TIMING while acting as MIDI LEAD for a drum-machine that is also playing from its own internal sequencer
		-- seems to mostly work
		-- however... Tine seems to be a tick behind the following-device, somehow
		. figure out why
			-- TICKCOUNT wasn't being reset. tested this change and it seems to work now

	-- added a BLINK to sendClockReset()
	-- fixed the SHIFT command in PLAY-MODE to shift the global-CUE point by the correct amount again

	. sequence-LEDs are not illuminated in PLAY MODE after toggling back from RECORD MODE. figure out why
		-- refreshPlayCustoms() wasn't checking for a TOGGLE RECORD-MODE keychord. fixed now

	-- changed lower BPM boundary back to 32
	-- took a block of code from the middle of loadSong() and made it into sendInvalidBPMGlyph()
	-- changed clearCmd() to have a whole-note granularity in both its erase-point and its erase-size

	. COPY/PASTE is really extraneous to any sane workflow, so...
		. remove COPY/PASTE funcs from func_cmd.ino
			-- done
		. remove COPY/PASTE CmdFunc entries, and restructure other funcs around them
			-- done
			. reflect these changes in button-key.txt
				-- done
			. move other commands around in button-key.txt once the keychords for COPY/PASTE have been freed up
				-- done
				. reflect this change in the CmdFunc entries
					-- done
		. remove COPY/PASTE glyphs
			-- done
		. change that one manual call to the BPM-glyph's position again
			-- done

	-- SHIFT POSITION's glyph was off by a couple rows in PLAY MODE. fixed it
	-- ARP MODE and ARP REFRESH weren't displaying their upper-row GUI. fixed it
	-- removed outdated COPYPOS/COPYSEQ from the prefs-file (forgot to do this earlier)

	. in RECORD-MODE, single-note presses should display that note's pitch as a conventional note-name in the GUI
		-- added this to the code
		. wait: does C = 12, 24, 36 etc. in the MIDI spec?
			-- yes. just had to make sure
		. test it
			-- the GUI code for note-glyphs is messed up somehow
			. figure out what's wrong
				-- note-button GUI checker was selecting GLYPH_PITCHES rows wrong
		. test again
			-- still not working right
			. find the issue
				-- forgot to use pgm_read_byte_near()
				-- I am an idiot
			-- also added a TO_UPDATE flag to unassignKey()'s RECORD-MODE block, so note-glyphs are wiped off the screen when the keystroke is lifted
		. test again
			-- seems to work
			-- also: changed some of the note-glyph and number-glyph shapes
			. when holding a note-button and releasing a control-button, it displays the wrong value. fix this
				-- fixed: added a tracking-flag and tweaked some logic-flow

	-- changed activateStep() to give more human-readable BLINKL/BLINKR performance when RECORDNOTES is armed

	. STATS[] should hold the seq's size in whole-notes, not half-notes
		-- am doing
	. change file-format, and all file functions, so seqs are 8192 large
		-- done
	. update data-format.txt
		-- done
	. change everything that engages with STATS[] to compensate for the shift to whole-note granularity
		-- done afaict
	. change the GUI for the second LED-row in RECORD-MODE, to increment on whole-notes rather than quarter-notes...
	. ...and get rid of its flashing behavior, which is now extraneous
		-- done
	. change CUR32 to go to 256 rather than 128
		-- done
	. change all CUR32-related mechanisms to compensate for CUR32's new max size
		-- done afaict
	. wipe SD-card again, and upload new firmware while doing so
		-- sd-card wiped. firmware uploaded
	. initial test of updates
		-- PLAY MODE's top-row GUI is displaying wrong
		. fix it
			-- fixed
		. re-test
			-- RECORD MODE's top-row GUI has a similar problem
			. fix it
				-- fixed. also, refactored some duplicate code into sendRegularCueRow()
		. re-test
			-- on mode-toggle, GLOBAL CUE seems to get set to 127 instead of 255
			. fix it
				-- fixed: CUR32's value was being set to 127 instead of 255 in resetAllTiming()
		. re-test
			-- SHIFT POSITION doesn't move GLOBAL CUE by the right amount, and its movement wraps halfway through the GLOBAL CUE point
			. fix these problems
				-- fixed both of these in posCmd().
				-- also, SHIFT POSITION now applies across both PLAY MODE and RECORD MODE without any duplicate code
					-- also updated the GUI for SHIFT POSITION in PLAY MODE
			-- in RECORD-MODE, the seq-position LED-row isn't working
			. fix seq-position LED-row in RECORD MODE
				-- fixed: updateSecondRow() was checking for a 0 in the seq's POS when that value would have been set to 1 earlier in the tick's iteration-routine
				-- also tweaked the bitwise arithmetic in updateSecondRow() to give the seq-LED-row correct positioning
	. test regular-sequence recording
		-- in the context of how it controls REPEAT distance, QUANTIZE doesn't extend any further than a half-note, at settings larger than a half-note.
		. figure out why
			-- could it just be a case of QRESET being smaller than QUANTIZE during the testing-event that uncovered the "bug"? if so, then this isn't a bug
				. test for this
					-- yes, this seems to be the case. so nothing is actually going wrong here.
		-- RECORDNOTES doesn't seem to get unset when RECORD-MODE is toggled
		. figure out why
			-- forgot to disarm note-recording in toggleRecordMode(). fixed now
			. re-test
				-- works now
		-- sequence-activity sometimes doesn't get displayed when the GUI toggles back into PLAY-MODE
		. figure out why
			-- updatePlayBottomRows() seems to be interpreting certain held-key-combos as SCATTER chords on the key-release after mode-toggle.
			-- need to update the bottom 6 GUI-rows whenever a SCATTER chord is released.
			. do this
				-- simplified refreshPlayCustoms() because catching every special-case is no longer worth it
				. re-test
					-- seems to work now
	. test regular-sequence playback
		-- seems okay
	. test long-sequence recording
		-- seems to work
	. test long-sequence playback
		-- seems to work
	. test regular-sequence timed cues and beatslicing
		-- seem to work

	. change SWING:
		. remove recordable SWING-commands
			-- done
		. change the UPPER CHANNEL BITS CmdFunc to exclude the block that was previously taken up by recordable SWING commands
			-- done
		. update data-key.txt accordingly
			-- done
		. remove table of constants related to SWING
			-- done
		. simplify the way tempo is calculated
			-- done
		. change SWING AMOUNT and SWING GRANULARITY CmdFuncs, to deal with 32nd-notes rather than abstract swing-values
			-- done
		. change files so that SGRAN and SAMOUNT are saved as global prefs, rather than per-file prefs
			-- done
		. actually just remove all remnants of SWING, SGRAN, and SAMOUNT, since this can't even be repurposed for recording without getting too hairy:
			. remove SGRAN/SAMOUNT vars
				-- done
			. remove SGRAN/SAMOUNT CmdFunc entries, and move other CmdFuncs to compensate
				-- done
			. remove SWING glyphs, and update manual glyph calls
				-- done
			. remove SWING-related top-row GUI events
				-- done
			. remove SWING CmdFuncs themselves
				-- done
			. remove SGRAN/SAMOUNT file-vars (P.DAT, functions that modify P.DAT, prefs-format.txt, etc)
				-- done
			. change button-key.txt to remove SWING commands
				-- done
		. add a global "OFFSET" var, to change QUANTIZE's base-point
			. add the OFFSET var itself
				-- done
			. change button-key.txt to add OFFSET
				-- done
			. add a CmdFunc entry for it, and move other CmdFuncs to compensate
				-- done
			. add an OFFSET glyph, and update manual glyph calls
				-- done
			. add an OFFSET-related top-row GUI event
				-- done
			. add the OFFSET CmdFunc itself in func_cmds.ino: OFFSET should also be bounded by QUANTIZE
				-- done
			. add OFFSET's functionality to the recording-mechanisms: positive or negative offset gets applied to the base QUANTIZE-point
				-- done
			. the logic that decides whether or not to play a note while recording in realtime, should also apply the OFFSET value
				-- no changes are necessary here, since processRecAction() checks only for presence on the current tick, in this regard
		. update timing system to be based on floats rather than integers
			-- done

Hardware:

	. print out the alpha-prototype's schematic for reference while making updates (KiCad can corrupt a project if more than 1 is open)
		-- done

	. double-check that the indicators have protection-diodes and protection-resistors on them
		. protection-resistors in front of each first transistor's base terminal
			-- yes
		. protection-diodes between the MIDI data-lines and the first protection-resistors
			-- yes

	. figure out how to stabilize the LEDs while soldering, so their wobbly resin base doesn't set them at slight angles
		. should each LED just have a very short standoff? (2mm-ish?)
			-- yes

	. research how many milliamps the standard MIDI-OUT connection uses, to prevent the possibility of frying power components
		-- 5mA per connection, negligible amount even if both ports are driving quad splitters

	. breadboard and test a regular MIDI-IN LED indicator circuit, alongside a simplified version of the same MIDI-IN LED-indicator circuit:
		. inverted MIDI signal -> inverter stage -> buffered regular MIDI signal <- 330ohm/220ohm R <- LED <- 5v
			-- it works perfectly. sheesh
		. if this works just as well, then:
			. update schematic
				-- done
			. revise indicator-circuit-related TODO tasks
				-- done

	. breadboard a dummy-sequencer with no buttons or screen, and test a new MIDI port setup:
		. no MIDI-THRU! (feature would be too rarely used, on this particular kind of device)
		. 1x MIDI-IN + indicator LED
		. 2x MIDI-OUT + indicator LED
		-- OUT ports don't work for some reason
		. troubleshoot
			-- doesn't seem to be the circuit itself
			. test the MIDI ports:
				. on a better breadboard
					-- still doesn't work
				. with alligator clips
					-- still doesn't work
			. test with code that only addresses a specific MIDI channel, rather than all of them in order
				-- still doesn't work
			. build testing-circuit from scratch with new components
				-- nope
			. the testing-chip is the wrong kind: ATMEGA328-PU (wrong) instead of ATMEGA328P-PU (the correct kind)
				-- I'm cussing, but also relieved
				. find an ATMEGA328P-PU and slot it in, then test
					-- still doesn't work. oh my god
					. in that case... find more potential problem sources
						-- the testing-chip's processing rate seems to be slowed by a factor of 8, for some reason (this is impacting delay() et al)
						. figure out what could be causing that
							-- apparently a fresh chip needs its bootloader re-burned, to set the fuses correctly
							. do that, and test again
								-- it works now. oof
		. re-test multi-OUT circuit
			-- MIDI-IN doesn't seem to be working
			. test with a proper IN source
				-- it works now
