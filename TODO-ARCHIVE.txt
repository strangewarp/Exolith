

Tine TODO-ARCHIVE (to keep a record of already-finished tasks)

Software:

	. figure out why the savefile system defaults to file "04"
		-- loadPrefs() was missing a makePrefBuf() call, inside its "if (!sd.exists(pn)) ..." clause
		. check whether this fixes things
			-- seems to have fixed it

	-- found a UI bug: copyCmd had the wrong numerical value in KEYTAB[]

	. check whether there's an additional "MIDI Tempo" SYSEX command, or whether it's solely dictated by TEMPO TICK events
		-- yeah but it's a 4-byte SYSEX command. so...
		. change all sequencing mechanisms in the following ways:
			-- am doing
			. BPM command is now a 2-byte command, in the format of "240 x 0":
				. "x": the BPM value (bounded to 16-200)
					-- ok
			. change note-entry system to allow BPM commands to be entered
				-- done
			. when a BPM command is encountered by the sequencing mechanism, only change the internal BPM value; do not actually send anything to MIDI-OUT
				-- done
			. anything that checks for 2-byte or 3-byte commands, or command-type in general, needs to be double-checked for conflicts with the BPM command type
				-- ok

	-- also moved the MOUT_COUNT checking mechanism into parseTickContents(), since every BPM-CHANGE needs to be caught, regardless of how full MOUT_COUNT gets.
		-- this hypothetically slightly reduces performance, could revert it later if I need to

	-- updated chanCmd() to compensate correctly for the validity of command-values of 240
	-- updated upperBitsCmd() similarly

	. make the BPM command accessible through both PLAY MODE and RECORD MODE, with the same control-button chord
	.     (this is especially necessary so the user can compensate for blunders related to slicing into a bad BPM during a performance)
		-- am doing
		-- chord number: 010001 (in-code: 100010)
		. update button-key.txt
			-- done
		. change BPM's behavior in assignKey() et al
			-- am doing
			. for PLAY MODE
				-- done
		. change BPM's key-chord in RECORD MODE
			-- done
			. change command-lists in data_cmds.ino
				-- done
		. add a "BPM" indicator to the GUI for PLAY MODE
			-- done
		. change the "BPM" case in the GUI for RECORD MODE
			-- done
		. remove "todo update" entries from button-key.txt
			-- done

	. add "BPM" glyph to PLAY MODE's BPM command
		-- am doing
		. update TO_UPDATE flags in unassignKey() and parsePlayPress() to cover the bottom 6 rows as well
			-- done
		. update GUI parser in updatePlayBottomRows() to display the BPM-glyph when a BPM chord is held
			-- done

	-- fixed a one-off error for the "col" value in the call to tempoCmd() from parsePlayPress()
	-- fixed the manner in which updatePlayBottomRows() displays the TEMPO glyph when PLAY MODE's BPM command is held
	-- made the BPM sigil appear in PLAY MODE at all the correct times

	. unknown command-types in RECORD MODE need to set a TO_UPDATE flag for the bottom 6 rows (currently seems to only flag top row)
		-- fixed: it was a mismatched value in the KEYTAB array

	-- found and (probably) fixed a bug where all sequenced notes were acting like they had a duration of 0
	-- changed writeCommands() to correctly overwrite BPM-change commands
	-- fixed the ERASE WHILE HELD glyph to change its appearance depending on whether note-recording is active

	-- updated the MIDI-IN system to only call file.sync() once per tick max, to save on SD-card wear (still requires testing)
	-- increased the length of the BLINK that occurs on each QUANTIZE tick in RECORD MODE

	. change REPEAT so that held chords are recorded into TRACK 1 & 2 simultaneously
		-- done
	. in RECORD MODE, BLINK should only illuminate the half of the screen that corresponds to the current TRACK
		-- done

	-- made recording-blinks longer in RECORD-MODE
		-- tweaked the duration for this again

	. redesign the top LED-row in RECORD MODE:
		-- am doing
		. the quantize-tick should only be displayed in LEDs 5 and 6
			-- done
		. the currently-active TRACK should be displayed in LEDs 7 and 8
			-- done

	-- refactored the "flip number values into correct format" line in parsePlayPress()
	-- fixed a labeling mistake in button-key.txt
	-- removed superfluous parentheses from updateGlobalRand()

	. since the meaningful GUI signifiers for QUANTIZE and TRACK are now being handled by the BLINK system...
		. in RECORD MODE, change the top GUI row to only show the global-cue's current beat
			-- done
		. in PLAY MODE...
			. change the top GUI row to only show the global-cue's current beat
				-- done
			. if PAGE B is active, then invert the second GUI row's illumination
				-- done
		. change all TO_UPDATE calls related to these things
			-- done

	-- lightly refactored updateSecondRow()
	-- fixed some slight bad text-formatting in buttons-key.txt

	. add a QRESET command, which will reset QUANTIZE's anchor point every n ticks
		-- am doing
		. change the REPEAT system to make this distinction
			-- done
		. change all related BLINK and TO_UPDATE calls
			-- afaict done
		. change the prefs-file routines to add a QRESET slot
			-- done
		. change all relevant GUI calls
			-- done
		. add CmdFunc and glyph for QRESET
			-- done
		. add GUI routines for QRESET
			-- done

	. wipe the SD-card again before testing, since the prefs-file format has been changed
		-- ok

	-- added a blink effect whenever a note is played in RECORD-MODE, regardless of whether RECORDNOTES is armed

	. write a stripped-down replacement for LedControl, to save RAM space
		-- am doing
		. write "initialize" and "send line" functions
			-- done
		. change updateGUI() to open and close the MAX72** chip's data-latch on digital pin 6
			-- done
		. change all GUI-related functions to use sendRow() instead of LedControl calls
			-- done

	. new LED system doesn't work. figure out why
		-- figured it out: every row-send command must be surrounded by its own set of CS-pin latch commands. these are now in sendRow()
		-- also might have been that sendRow() requires "volatile byte" typing. this is mysterious. leaving it in to be thorough

	-- removed an extraneous PORTD call from maxInitialize()

	-- slightly lengthened the BLINK duration when a note-key is pressed in RECORD-MODE

	. GUI is non-responsive after powering back up. figure out why
		-- still not sure of the exact cause, but, fixed it by restructuring maxInitialize(), sendRow(), and creating sendMaxCmd()

	-- found and fixed a SCATTER bug in parseScatter() even though I'm not testing that yet
	-- added clarification to a readTick() call inside of getTickNotes(), since it could easily be mistaken for a SCATTER bug

	. QUANTIZE/QRESET don't hit the right ticks when containing unusual values. fix it
		-- am doing
		. seems to go out of whack specifically when QRESET is at a value lower than 32. what's causing this
			. wait... is this just the testing apparatus again, combined with some user error (selecting QRESET of 8 when I thought it was 16)?
			-- this is the third time this has happened
			-- horrible. horrible. the bug never existed in the first place

	-- fixed a glyph-display error for PLAY MODE's BPM command

	. in PLAY MODE, BPM conflicts with CUE-OFF
		. this means:
			. the PLAY MODE section of button-key.txt is actually reversed, except for the "BPM" entry. fix it
				-- done
			. the BPM command needs to be mirrored to (top-down) 100010
				-- am doing
				. update CmdFunc system for this
					-- done
				. update GUI routines for this in PLAY MODE and RECORD MODE
					-- done
			. the QRESET command, which takes up (top-down) 100010 in RECORD MODE, needs to be moved to (top-down) 010010
				-- am doing
				. update CmdFunc system for this
					-- done
				. update GUI routines for this in RECORD MODE
					-- done

	-- replaced other references to the outdated BPM keychord in func_gui.ino
	-- removed the BLINK event on any BPM modification in PLAY MODE, for UI consistency
	-- refactored BLINK and TO_UPDATE flags in parsePlayPress()

	. test: do the repositioned QRESET and BPM commands work right?
		-- yes
	. has OFF CUE 0 been freed up correctly?
		-- yes

	. change the BLINK system:
		. divide BLINK into BLINKL and BLINKR, which are decremented in the same way that BLINK is
		. (BLINKL and BLINKR will simplify the need to show notes playing on tracks in RECORD MODE)
			-- ok
		. rewrite func_timer.ino to decrement both BLINKL/R types simultaneously
			-- done
		. rewrite all BLINK commands to flag BLINKL, BLINKR, or both, depending on context
			-- done
		. rewrite GUI routines to remove situational cruft, and to instead follow BLINKL and BLINKR straightforwardly
			-- done

	. when RECORD MODE is active, and RECORDNOTES is unarmed, and REPEAT is not active,
	.     a BLINK should occur for every note playing on each of the two tracks within the seq
	. (this will allow users to quickly know which track a seq's notes are playing on, because nobody can be expected to remember that, and it gets frustrating)
		-- done

	. test GUI changes
		. RECORD MODE [blink on note presence by track]
			-- forgot to include a TO_UPDATE call after the BLINK-setting mechanism in parseTickContents()
			. test again. does it work?
				-- both inaccurate blink-timing, and incomplete blink-shape in UI
				. what's causing inaccurate blink-timing?
					-- incorrect manipulation of the contents of BLINKL/BLINKR in updateRecBottomRows()
				. what's causing incomplete blink-shape?
					-- incorrect manipulation of the contents of BLINKL/BLINKR in updateRecBottomRows()
		. BLINKs during REPEAT
			-- seem ok
		. RECORDNOTES flag's impact on BLINK style
			-- seems correct
		. BLINK's response to TRACK-switching
			-- seems correct
		. CUE commands in PLAY MODE
			-- seems fine

	-- removed the BLINKs from...
		-- completed CUE commands in PLAY MODE (parseCues()),
		-- PLAY MODE CUE-chord-presses (parsePlayPress()),
	-- ...as there will now be visual confirmation related to flashing seq-LEDs

	. add a SEQFLASH system to PLAY MODE, so that any seqs with pending CUE commands will blink in certain ways:
		-- am doing
		. already-active seqs blink ON and OFF every quarter-note:
			. add a CUE-checking routine that sets a TO_UPDATE flag in parseCues()
				-- done
			. add a rendering routine for this to updatePlayBottomRows()
				-- done
		. currently-OFF seqs blink every half-note
			-- ok
		. test this
			-- seems to work

	. the seq-flash, in PLAY MODE, is reversed chronologically. it should be on-off-on-off but that is reversed. fix it
		-- fixed

	. for seqs that are OFF and have a dormant CUE, a half-note-sized flash-cycle is too visually confusing in-the-moment. so...
		. make them both have quarter-note flash-cycles, but with reversed flash-timing
			-- done
			-- also changed the logic around the related TO_UPDATE call in parseCues() so it is activated on a quarter-note for every seq with a dormant-cue

	. flashing-seqs still read in a visually confusing way when both CUE and CUE-OFF seqs are flashing at the same time, especially at low tempo.
		. the only reasonable way to fix this would be...
			. update a seq-LED on the first and second 16th-note within each half-note, with currently ON and OFF seq blinking in opposite ways
				-- done

	. needs to be a MIDI PANIC on startup, to compensate for any accidental power-cycles in the middle of SUSTAINs
		-- done

	. do sequences FLASH when they are empty and receive a CUE-OFF command?
		-- yes
		. should something be done about this?
			-- probably
			. cut this out at the source: don't let CUE-OFF commands get applied to already-off seqs
				-- done

	-- removed the first sendRow() from midiPanic(), since the first series of "ALL NOTES OFF" commands is too quick to be visible

	. move CUE button to second-bottommost row, and shift the 1-2-4 buttons upwards by 1 row?
	. (seems like this would be more intuitive UI - "off" and "cue" are used in concrete ways, whereas the numbers are used in abstract ways)
		. change all "CUE, 1, 2, and 4"-button-related entries in the PLAY MODE section of button-key.txt
			-- am doing
			. change most PLAY MODE-related commands
				. go through the codebase looking for everything related to a PLAY MODE keypress and updating as necessary
					-- done
			. change BPM command (again)
				. BPM: (top-down) 110000
					-- changed its entries in buttons-key.txt
					-- changed its CmdFunc entry

	. mystery crash after allowing RECORD MODE to sit for a while. figure out what it is
		-- no idea. hopefully the recent increase in free RAM will stop this type of weird event from happening

	. test all updated command-chords
		-- BPM-command doesn't work in PLAY MODE
		. fix it
			-- fixed: forgot to update the command-chord for BPM-presses in assignKey()

	. when notes are being entered with REPEAT active, the note gets retriggered twice on the entry-tick. this is bad. fix it
		-- fixed it by inserting an if-then-return clause at a specific point in processRecAction()
	. test the fix
		-- seems to work correctly

	. test changes:
		. is BLINK affected by the active TRACK in RECORD MODE?
			-- yes
		. do QUANTIZE and QRESET both work correctly...
			. in the GUI?
				-- yes
			. in regular note-entry?
				-- seems so
			. in REPEAT-based note-entry?
				-- yes
		. does REPEAT record held chords, but with recording otherwise acting monophonically?
			-- yes
		. how many notes are actually played when more than 2 are held with REPEAT active?
			-- always 2, which is reasonable

	-- removed redundant if-then statements for SCATTER behavior in parsePlayPress()
	-- changed assignKey() and unassignKey() so their BPM-and-SHIFT-checking routines are collapsed into a single external function: refreshPlayCustoms()
	-- clarified that SHIFT RECORDING POSITION works differently, and serves a different purpose, from SHIFT CUE
	-- fixed an outdated TO_UPDATE-checking line in parseRawMidi()

	. add a SHIFT GLOBAL CUE command, to shift the position of the global cue-point forward or backward by one step in PLAY MODE
		-- am doing
		. allocate a command-chord in buttons-key.txt
			-- done
		. add a clause to the PLAY MODE keypress routines
			-- done
			. should change the global CUR16 value, but not any seqs' POS values
				-- ok
		. add a standalone GUI-GLYPH for SHIFT
			-- done
		. add a GUI-routine to display the glyph
			-- done
		. test it by itself, particularly going over every possible off-by-one case
			-- fixed a bug where the SHIFT glyph was being loaded from PROGMEM wrong, due to an offset "i" var in updatePlayBottomRows()
			-- seems fine
		. test it with various cued-commands active in various sequences
			-- freezes during certain OFF-cmd configurations
			. figure out what's going on
				-- freezes occur when SHIFT is held while a sequence is in CUE-OFF state, but only sometimes
				. what is happening specifically?
					-- could be that the other if-then checks in parsePlayPress() are screwing with something somehow
					. fix the spaghetti-code there
						-- ok
					. mash the various crash-related commands again for a while: find any more crashes now?
						-- yes: sometimes the CUR16 point seems to stop advancing, when SHIFT is being held, during certain CUE-commands...
						-- ... but it doesn't seem to be an easily-replicable bug for some reason
	. SHIFT debugging cont'd:
		-- seems related to: shifting the cue forward by 1(16) while one or several sequences have CUE-OFF 0 in their CUE-value.
		-- ...at which point, the CUR16 stops advancing(?!)
		. figure out what to do
			-- changed "char" to "int" in the CUR16-updating line in parsePlayPress()
			. are there still crashes now?
				-- tentatively, I am not finding any
	. also encountering a bug related to the SHIFT-freeze bug, where LEDs will seem to be pulling partially-formed glyphs from memory in PLAY MODE
		-- this seems to have gone away as well

	. double-check: can the CHAN byte's upper bits only be changed by the UPPER CHAN BYTES command, as they should?
		-- yes

	-- updated some BPM-manipulation routines to use BPM_LIMIT_LOW and BPM_LIMIT_HIGH instead of hardcoded limit values
	-- changed the BLINKL/BLINKR calls in processRecAction() to add their values to whatever other BLINK values might be present
	-- fixed the entry of BPM-commands in processRecAction() so that they would correctly apply the same recorded HUMANIZE-modded-VELO to the current BPM
	-- writeCommands() was comparing saved BPM commands to the global BPM var, instead of the value that was actually passed to the function. fixed this

	. on every MIDI-OUT, look through the SUSTAIN system for the same note on the same channel, and if it is present, send a NOTE-OFF before the NOTE-ON
	. (this will allow certain synths to obey conflicting QUANTIZE and DURATION settings without wigging out)
		-- had to also apply this mechanism to MOUT, to prevent weird effects from duplicate notes on the same tick
		-- subsequently had to refactor the SUSTAIN and MOUT systems

	. add global SWING values, set per-song like BPM
		. create SWING GRANULARITY and SWING AMOUNT vars
			-- done
		. crate a SWING SECTION var, to track which section of swing is currently active
			-- done
		. change savefile format in data-format.txt to add SWING values for every save-slot
			-- done
		. change all file-read and write calls, to compensate for the presence of the new SWING-value bytes within each save-slot
			-- changed FILE_BYTES. also noticed that FILE_BYTES was originally a few bytes too small, which means the program would have had horrible bugs trying to access the last notes in the end of the last sequence. yikes! fixed it while changing FILE_BYTES
			-- updated define-statements to hold more characteristics of savefiles
			-- done, afaict
		. change file-load to put the file's SWING values into the global SWING vars
			-- done
		. change RECORD-MODE TOGGLE so that:
			. the SWING values are saved alongside the BPM value
				-- done
			. SWING PART is reset to 0 on every toggle between RECORD-MODE and PLAY-MODE
				-- done: I put this into resetAllTiming()
		. create entries in buttons-key.txt for SWING commands in RECORD MODE
			-- done
		. create CmdFunc entries for SWING GRANULARITY and SWING AMOUNT
			-- ok
			. when SWING GRANULARITY is changed, SWING SECTION should be checked against the new section-size and changed accordingly
				-- ok: a new function called updateSwingPart() does this now
		. create glyphs for SWING GRANULARITY and SWING AMOUNT
			-- done
		. edit CmdFunc apparatus to compensate for the presence of new glyphs
			-- done
		. shift other manual glyph calls in func_gui.ino (BPM/TEMPO glyph)
			-- done
		. on GUI for SWING-AMOUNT: top row should fill its left side for pre-swing, and fill its right side for post-swing, up to -64/+64 on respective sides
			-- done (definitely needs testing)
		. update top-row GUI for SWING-GRANULARITY
			-- done
		. change timing routines to compensate for SWING
			-- am doing
			. split TICKSIZE into "TSIZE1" and "TSIZE2" vars, to hold values equal to each side of the current SWING-amount in microseconds
				-- done
			. update every function that references TICKSIZE
				-- done
			. update TICKSZ1 and TICKSZ2 on every SWING AMOUNT change
				. for manual SWING AMOUNT via CmdFunc
					-- done
				. for automatic SWING AMOUNT via sequenced SWING GRAN commands
					-- done
		. change sequencing functions to incorporate SWING commands
			-- am doing
			. limits of the upperChanBits CmdFunc should now be 96 - 224, and any value below 128 should wipe the *lower* chan bits automatically
				-- ok
				. update sequenced/saved BPM commands to occupy a command-byte value of 112
					-- done
				. update the CmdFunc for UPPER CHAN BYTES to accomodate the new command-byte value-range
					-- done
				. update all sequencing routines that check for any kind of command-byte number
					-- done afaict
			. command-entry in RECORD MODE
				-- done afaict
			. sequencing in PLAY MODE
				-- done afaict
		. call updateSwingPart() after updating CUR16 in the timer func
			-- done
		. writeCommands() should recognize SWING commands in its wear-reduction mechanism
			-- done

	-- split updateTimer() into 4 smaller functions: updateTimer(), blinkDecay(), advanceTick(), and activateStep()

	. meticulously check that updateTimer() can handle situations where the micros-since-last-tick is many times greater than the micros-to-next-tick value
		-- seems ok: uses "if" instead of "while", relying instead on the main-loop itself
		. also make sure that it won't run many iterations of iterateAll() in such a situation without re-checking, because SWING may change back around
			-- aye, see above

	-- refactored the functions in func_timer.ino, and moved the KEYELAPSED-checking mechanism from advanceTick() to scanKeypad() (in func_keypad.ino)
	-- removed duplicate TODO entries for the SWING system
	-- changed SAMOUNT's top-row GUI to use the same visual shorthand as RPTSWEEP's - namely, using a virtual-char-display for its byte-value

	. wipe the testing SD-card again, due to savefile format changes
		-- done

	. tempo seems slightly too slow. re-check BPM/SWING algorithms
		-- it was just the default BPM value being lower than I expected, I think
		-- changed default savefile BPM value from 80 to 100

	. add a RPTSWEEP var to RECORD MODE: this will cause any REPEAT command to store its velocity in the RPTVELO var
		. make a CmdFunc table entry for REPEAT-SWEEP, and update all other subsequent CmdFuncs in the list
			-- done
		. make the CmdFunc itself
			-- done
		. make a GUI-glyph for REPEAT-SWEEP
			-- done
		. update top-row to show negative/positive REPEAT-SWEEP values, using the same algorithm as the display for SWING-AMOUNT
			-- done
		. update manual call to BPM-glyph in func-gui to compensate for the new REPEAT-SWEEP glyph's presence
			-- done
		. subsequent REPEAT-triggers during the same keypress will change RPTVELO by the RPTSWEEP amount, and play/record at that velocity
			-- done
		. on any new note-button keystroke when REPEAT is enabled, RPTVELO should be set equal to VELO
			-- done
		. if REPEAT is enabled, then the HUMANIZE process should be based on RPTVELO instead of VELO
			-- ok
			. after a given REPEAT is processed, make sure RPTVELO has stored a raw reduced-RPTVELO velocity, not a velocity modulated by HUMANIZE for recording
				-- logic-flow seems correct for this

	-- moved updateTickSize() to func_timer.ino
	-- changed the name of "BPM_TABLE" to "MCS_TABLE"
	-- removed individual-note-offs from midiPanic(), since they're mostly-extraneous and cause a lot of startup lag

	. when a BPM command is activated in PLAY MODE, this primed the RECORDSEQ with an awkward and wrong value. fix it
		-- done: changed parsePlayPress() to check for PAGE-OFF, SCATTER, SCATTER UNSET, PAGE SCATTER UNSET, PAGE, SHIFT, and BPM

	-- changed the defaut position of RPTSWEEP so it sits at 128, which is its "middle" value
	-- added firmware-update process to tutorial-outline

	. test SWING modification
		-- horrible: changes in SWING value are erroneously changing the apparent tempo
		-- this seems to be at its worst when SWING AMOUNT is at or just below either 63 or 127
		. figure out what's going on
			-- updateTickSize()'s algorithm seems wrong
			. fix it
				-- having trouble finding the root of the problem:
				-- it looks like a problem with how TICKSZ1/TICKSZ2 are being interpreted, but there's nothing to be interpreting them the wrong way...
				-- ...which implies that the problem is in updateTickSize(), but the problem does not map to what could be being caused by that algorithm
				. continue looking and testing
					-- might've fixed it, after drawing some diagrams and rewriting the algorithm again
					-- found further bugs after mentally modeling the algorithm, and changed things around to correct for them
					. test it
						-- still not working. but: some testing-code has revealed that the TICKSZ1&2 vals are indeed being set correctly
						-- therefore: the problem is somewhere in the timing routines that *interpret* the TICKSZ vars
						. find the problem
							-- testing-code indicates that updateSwingPart() is staying at a value of 0 for some reason
							-- it can't be updateSwingPart(). however...
							-- SGRAN was being set to 0 on file-load, because createFiles() didn't have any commands to fill the stored SGRAN and SAMOUNT values
							-- so, added those commands to createFiles().
							. wipe SD-card again
								-- ok
							. test SWING for basic functionality again
								-- basic functionality achieved
			. re-test SWING-modification with notes, after applying fixes
				-- am doing
				. test with non-recorded-notes in RECORD MODE
					-- seems to work
				. test with plain recorded-notes
					-- seems to work
				. test with REPEAT
					-- it works
		. SWING-AMOUNT's GUI is off by one, on its negative side. fix it
			-- fixed
			-- this also fixed a related bug in REPEAT-SWEEP's GUI, which also relied on sendVirtualCharRow()

	. when two REPEAT-notes are being recorded/played in RECORD MODE, both sides of the screen should be covered by BLINK, not just one
		-- fixed: changed processRecAction() to use the given "trk" value, rather than the global "TRACK" value, when assigning BLINK-sides

	. BPM values are sometimes set to 255 on startup, when the SD-card hasn't been used for a while. figure out why
		-- no idea why. hmm...
		. figure out what to do
			-- I've put in a restart-function that gets called whenever the loaded BPM is 255.
			-- a do-while loop doesn't work here for whatever reason, but afaict, a total restart of the device fixes the problem.
			-- therefore, since the bug occurs on startup, and is relatively rare, calling a restart-function is the least-bad option to compensate for it.
			-- the bug itself seems to be some horrendous deep-wizard situation with the SD-card displaying unusual behavior that's impossible to replicate.
			-- but since it's a specific bug, with a specific unusual behavior that's always the same, the restart-function should take care of it.

Hardware:

	. print out the alpha-prototype's schematic for reference while making updates (KiCad can corrupt a project if more than 1 is open)
		-- done

	. double-check that the indicators have protection-diodes and protection-resistors on them
		. protection-resistors in front of each first transistor's base terminal
			-- yes
		. protection-diodes between the MIDI data-lines and the first protection-resistors
			-- yes

	. figure out how to stabilize the LEDs while soldering, so their wobbly resin base doesn't set them at slight angles
		. should each LED just have a very short standoff? (2mm-ish?)
			-- yes

	. research how many milliamps the standard MIDI-OUT connection uses, to prevent the possibility of frying power components
		-- 5mA per connection, negligible amount even if both ports are driving quad splitters

	. breadboard and test a regular MIDI-IN LED indicator circuit, alongside a simplified version of the same MIDI-IN LED-indicator circuit:
		. inverted MIDI signal -> inverter stage -> buffered regular MIDI signal <- 330ohm/220ohm R <- LED <- 5v
			-- it works perfectly. sheesh
		. if this works just as well, then:
			. update schematic
				-- done
			. revise indicator-circuit-related TODO tasks
				-- done

	. breadboard a dummy-sequencer with no buttons or screen, and test a new MIDI port setup:
		. no MIDI-THRU! (feature would be too rarely used, on this particular kind of device)
		. 1x MIDI-IN + indicator LED
		. 2x MIDI-OUT + indicator LED
		-- OUT ports don't work for some reason
		. troubleshoot
			-- doesn't seem to be the circuit itself
			. test the MIDI ports:
				. on a better breadboard
					-- still doesn't work
				. with alligator clips
					-- still doesn't work
			. test with code that only addresses a specific MIDI channel, rather than all of them in order
				-- still doesn't work
			. build testing-circuit from scratch with new components
				-- nope
			. the testing-chip is the wrong kind: ATMEGA328-PU (wrong) instead of ATMEGA328P-PU (the correct kind)
				-- I'm cussing, but also relieved
				. find an ATMEGA328P-PU and slot it in, then test
					-- still doesn't work. oh my god
					. in that case... find more potential problem sources
						-- the testing-chip's processing rate seems to be slowed by a factor of 8, for some reason (this is impacting delay() et al)
						. figure out what could be causing that
							-- apparently a fresh chip needs its bootloader re-burned, to set the fuses correctly
							. do that, and test again
								-- it works now. oof
		. re-test multi-OUT circuit
			-- MIDI-IN doesn't seem to be working
			. test with a proper IN source
				-- it works now


